/* automatically generated by rust-bindgen */

use sgxsd_ffi::{sgxsd_aes_gcm_key, sgxsd_aes_gcm_iv, sgxsd_aes_gcm_mac};
use core::arch::x86_64::*;

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub unsafe fn as_ptr(&self) -> *const T {
        ::core::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut_ptr(&mut self) -> *mut T {
        ::core::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
impl<T> ::core::clone::Clone for __IncompleteArrayField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const INTMAX_MIN: i64 = -9223372036854775808;
pub const INTMAX_MAX: u64 = 9223372036854775807;
pub const UINTMAX_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const RAND_MAX: u32 = 2147483647;
pub const MB_CUR_MAX: u32 = 1;
pub const false_: u32 = 0;
pub const true_: u32 = 1;
pub const __bool_true_false_are_defined: u32 = 1;
pub const SGX_FLAGS_INITTED: u32 = 1;
pub const SGX_FLAGS_DEBUG: u32 = 2;
pub const SGX_FLAGS_MODE64BIT: u32 = 4;
pub const SGX_FLAGS_PROVISION_KEY: u32 = 16;
pub const SGX_FLAGS_EINITTOKEN_KEY: u32 = 32;
pub const SGX_FLAGS_KSS: u32 = 128;
pub const SGX_XFRM_LEGACY: u32 = 3;
pub const SGX_XFRM_AVX: u32 = 6;
pub const SGX_XFRM_AVX512: u32 = 230;
pub const SGX_XFRM_MPX: u32 = 24;
pub const SGX_XFRM_RESERVED: i32 = -232;
pub const SGX_KEYSELECT_EINITTOKEN: u32 = 0;
pub const SGX_KEYSELECT_PROVISION: u32 = 1;
pub const SGX_KEYSELECT_PROVISION_SEAL: u32 = 2;
pub const SGX_KEYSELECT_REPORT: u32 = 3;
pub const SGX_KEYSELECT_SEAL: u32 = 4;
pub const SGX_KEYPOLICY_MRENCLAVE: u32 = 1;
pub const SGX_KEYPOLICY_MRSIGNER: u32 = 2;
pub const SGX_KEYPOLICY_NOISVPRODID: u32 = 4;
pub const SGX_KEYPOLICY_CONFIGID: u32 = 8;
pub const SGX_KEYPOLICY_ISVFAMILYID: u32 = 16;
pub const SGX_KEYPOLICY_ISVEXTPRODID: u32 = 32;
pub const SGX_KEYID_SIZE: u32 = 32;
pub const SGX_CPUSVN_SIZE: u32 = 16;
pub const SGX_CONFIGID_SIZE: u32 = 64;
pub const SGX_KEY_REQUEST_RESERVED2_BYTES: u32 = 434;
pub const SGX_HASH_SIZE: u32 = 32;
pub const SGX_MAC_SIZE: u32 = 16;
pub const SGX_REPORT_DATA_SIZE: u32 = 64;
pub const SGX_ISVEXT_PROD_ID_SIZE: u32 = 16;
pub const SGX_ISV_FAMILY_ID_SIZE: u32 = 16;
pub const SGX_TARGET_INFO_RESERVED1_BYTES: u32 = 2;
pub const SGX_TARGET_INFO_RESERVED2_BYTES: u32 = 8;
pub const SGX_TARGET_INFO_RESERVED3_BYTES: u32 = 384;
pub const SGX_REPORT_BODY_RESERVED1_BYTES: u32 = 12;
pub const SGX_REPORT_BODY_RESERVED2_BYTES: u32 = 32;
pub const SGX_REPORT_BODY_RESERVED3_BYTES: u32 = 32;
pub const SGX_REPORT_BODY_RESERVED4_BYTES: u32 = 42;
pub const MAX_EX_FEATURES_COUNT: u32 = 32;
pub const SGX_CREATE_ENCLAVE_EX_PCL_BIT_IDX: u32 = 0;
pub const SGX_CREATE_ENCLAVE_EX_PCL: u32 = 1;
pub const SGX_CREATE_ENCLAVE_EX_SWITCHLESS_BIT_IDX: u32 = 1;
pub const SGX_CREATE_ENCLAVE_EX_SWITCHLESS: u32 = 2;
pub const SGX_CREATE_ENCLAVE_EX_KSS_BIT_IDX: u32 = 2;
pub const SGX_CREATE_ENCLAVE_EX_KSS: u32 = 4;
pub const _SGX_LAST_EX_FEATURE_IDX_: u32 = 2;
pub const SGX_DEBUG_FLAG: u32 = 1;
pub const SGX_PLATFORM_INFO_SIZE: u32 = 101;
pub const SGXSD_AES_GCM_IV_SIZE: u32 = 12;
pub const SGXSD_AES_GCM_MAC_SIZE: u32 = 16;
pub const SGXSD_AES_GCM_KEY_SIZE: u32 = 32;
pub const SGXSD_CURVE25519_KEY_SIZE: u32 = 32;
pub const SGXSD_SHA256_HASH_SIZE: u32 = 32;
pub const _MM_HINT_ET0: u32 = 7;
pub const _MM_HINT_ET1: u32 = 6;
pub const _MM_HINT_T0: u32 = 3;
pub const _MM_HINT_T1: u32 = 2;
pub const _MM_HINT_T2: u32 = 1;
pub const _MM_HINT_NTA: u32 = 0;
pub const _MM_EXCEPT_INVALID: u32 = 1;
pub const _MM_EXCEPT_DENORM: u32 = 2;
pub const _MM_EXCEPT_DIV_ZERO: u32 = 4;
pub const _MM_EXCEPT_OVERFLOW: u32 = 8;
pub const _MM_EXCEPT_UNDERFLOW: u32 = 16;
pub const _MM_EXCEPT_INEXACT: u32 = 32;
pub const _MM_EXCEPT_MASK: u32 = 63;
pub const _MM_MASK_INVALID: u32 = 128;
pub const _MM_MASK_DENORM: u32 = 256;
pub const _MM_MASK_DIV_ZERO: u32 = 512;
pub const _MM_MASK_OVERFLOW: u32 = 1024;
pub const _MM_MASK_UNDERFLOW: u32 = 2048;
pub const _MM_MASK_INEXACT: u32 = 4096;
pub const _MM_MASK_MASK: u32 = 8064;
pub const _MM_ROUND_NEAREST: u32 = 0;
pub const _MM_ROUND_DOWN: u32 = 8192;
pub const _MM_ROUND_UP: u32 = 16384;
pub const _MM_ROUND_TOWARD_ZERO: u32 = 24576;
pub const _MM_ROUND_MASK: u32 = 24576;
pub const _MM_FLUSH_ZERO_MASK: u32 = 32768;
pub const _MM_FLUSH_ZERO_ON: u32 = 32768;
pub const _MM_FLUSH_ZERO_OFF: u32 = 0;
pub const _MM_DENORMALS_ZERO_ON: u32 = 64;
pub const _MM_DENORMALS_ZERO_OFF: u32 = 0;
pub const _MM_DENORMALS_ZERO_MASK: u32 = 64;
pub const _MM_FROUND_TO_NEAREST_INT: u32 = 0;
pub const _MM_FROUND_TO_NEG_INF: u32 = 1;
pub const _MM_FROUND_TO_POS_INF: u32 = 2;
pub const _MM_FROUND_TO_ZERO: u32 = 3;
pub const _MM_FROUND_CUR_DIRECTION: u32 = 4;
pub const _MM_FROUND_RAISE_EXC: u32 = 0;
pub const _MM_FROUND_NO_EXC: u32 = 8;
pub const _MM_FROUND_NINT: u32 = 0;
pub const _MM_FROUND_FLOOR: u32 = 1;
pub const _MM_FROUND_CEIL: u32 = 2;
pub const _MM_FROUND_TRUNC: u32 = 3;
pub const _MM_FROUND_RINT: u32 = 4;
pub const _MM_FROUND_NEARBYINT: u32 = 12;
pub const _SIDD_UBYTE_OPS: u32 = 0;
pub const _SIDD_UWORD_OPS: u32 = 1;
pub const _SIDD_SBYTE_OPS: u32 = 2;
pub const _SIDD_SWORD_OPS: u32 = 3;
pub const _SIDD_CMP_EQUAL_ANY: u32 = 0;
pub const _SIDD_CMP_RANGES: u32 = 4;
pub const _SIDD_CMP_EQUAL_EACH: u32 = 8;
pub const _SIDD_CMP_EQUAL_ORDERED: u32 = 12;
pub const _SIDD_POSITIVE_POLARITY: u32 = 0;
pub const _SIDD_NEGATIVE_POLARITY: u32 = 16;
pub const _SIDD_MASKED_POSITIVE_POLARITY: u32 = 32;
pub const _SIDD_MASKED_NEGATIVE_POLARITY: u32 = 48;
pub const _SIDD_LEAST_SIGNIFICANT: u32 = 0;
pub const _SIDD_MOST_SIGNIFICANT: u32 = 64;
pub const _SIDD_BIT_MASK: u32 = 0;
pub const _SIDD_UNIT_MASK: u32 = 64;
pub const _CMP_EQ_OQ: u32 = 0;
pub const _CMP_LT_OS: u32 = 1;
pub const _CMP_LE_OS: u32 = 2;
pub const _CMP_UNORD_Q: u32 = 3;
pub const _CMP_NEQ_UQ: u32 = 4;
pub const _CMP_NLT_US: u32 = 5;
pub const _CMP_NLE_US: u32 = 6;
pub const _CMP_ORD_Q: u32 = 7;
pub const _CMP_EQ_UQ: u32 = 8;
pub const _CMP_NGE_US: u32 = 9;
pub const _CMP_NGT_US: u32 = 10;
pub const _CMP_FALSE_OQ: u32 = 11;
pub const _CMP_NEQ_OQ: u32 = 12;
pub const _CMP_GE_OS: u32 = 13;
pub const _CMP_GT_OS: u32 = 14;
pub const _CMP_TRUE_UQ: u32 = 15;
pub const _CMP_EQ_OS: u32 = 16;
pub const _CMP_LT_OQ: u32 = 17;
pub const _CMP_LE_OQ: u32 = 18;
pub const _CMP_UNORD_S: u32 = 19;
pub const _CMP_NEQ_US: u32 = 20;
pub const _CMP_NLT_UQ: u32 = 21;
pub const _CMP_NLE_UQ: u32 = 22;
pub const _CMP_ORD_S: u32 = 23;
pub const _CMP_EQ_US: u32 = 24;
pub const _CMP_NGE_UQ: u32 = 25;
pub const _CMP_NGT_UQ: u32 = 26;
pub const _CMP_FALSE_OS: u32 = 27;
pub const _CMP_NEQ_OS: u32 = 28;
pub const _CMP_GE_OQ: u32 = 29;
pub const _CMP_GT_OQ: u32 = 30;
pub const _CMP_TRUE_US: u32 = 31;
pub const _XBEGIN_STARTED: i32 = -1;
pub const _XABORT_EXPLICIT: u32 = 1;
pub const _XABORT_RETRY: u32 = 2;
pub const _XABORT_CONFLICT: u32 = 4;
pub const _XABORT_CAPACITY: u32 = 8;
pub const _XABORT_DEBUG: u32 = 16;
pub const _XABORT_NESTED: u32 = 32;
pub const __PCONFIG_KEY_PROGRAM: u32 = 1;
pub const _MM_PCOMCTRL_LT: u32 = 0;
pub const _MM_PCOMCTRL_LE: u32 = 1;
pub const _MM_PCOMCTRL_GT: u32 = 2;
pub const _MM_PCOMCTRL_GE: u32 = 3;
pub const _MM_PCOMCTRL_EQ: u32 = 4;
pub const _MM_PCOMCTRL_NEQ: u32 = 5;
pub const _MM_PCOMCTRL_FALSE: u32 = 6;
pub const _MM_PCOMCTRL_TRUE: u32 = 7;
pub const CDS_HASH_LOOKUP_ERROR_HASH_TABLE_OVERFLOW: u32 = 3;
pub const CDS_HASH_LOOKUP_ERROR_INVALID_PARAMETER: u32 = 1;
pub const CDS_HASH_LOOKUP_ERROR_LAST: u32 = 3;
pub const CDS_HASH_LOOKUP_ERROR_RDRAND: u32 = 2;
pub const CDS_HASH_LOOKUP_SUCCESS: u32 = 0;
pub const CDS_MAX_HASH_TABLE_ORDER: u32 = 13;
pub const CHAR_BIT: u32 = 8;
pub const SCHAR_MAX: u32 = 127;
pub const SCHAR_MIN: i32 = -128;
pub const UCHAR_MAX: u32 = 255;
pub const CHAR_MAX: u32 = 127;
pub const CHAR_MIN: i32 = -128;
pub const MB_LEN_MAX: u32 = 1;
pub const USHRT_MAX: u32 = 65535;
pub const SHRT_MAX: u32 = 32767;
pub const SHRT_MIN: i32 = -32768;
pub const UINT_MAX: u32 = 4294967295;
pub const INT_MAX: u32 = 2147483647;
pub const INT_MIN: i32 = -2147483648;
pub const ULONG_MAX: i32 = -1;
pub const LONG_MAX: u64 = 9223372036854775807;
pub const LONG_MIN: i64 = -9223372036854775808;
pub const ULLONG_MAX: i32 = -1;
pub const LLONG_MAX: u64 = 9223372036854775807;
pub const LLONG_MIN: i64 = -9223372036854775808;
pub const LONG_BIT: u32 = 64;
pub const CTTK_HEX_PAD_ODD: u32 = 1;
pub const CTTK_HEX_SKIP_WS: u32 = 2;
pub const CTTK_HEX_UPPERCASE: u32 = 1;
pub const CTTK_B64DEC_NO_PAD: u32 = 1;
pub const CTTK_B64DEC_NO_WS: u32 = 2;
pub const CTTK_B64ENC_NO_PAD: u32 = 1;
pub const CTTK_B64ENC_NEWLINE: u32 = 2;
pub const CTTK_B64ENC_CRLF: u32 = 4;
pub const CTTK_B64ENC_LINE64: u32 = 8;
pub type __int8_t = libc::c_schar;
pub type __uint8_t = libc::c_uchar;
pub type __int16_t = libc::c_short;
pub type __uint16_t = libc::c_ushort;
pub type __int32_t = libc::c_int;
pub type __uint32_t = libc::c_uint;
pub type __int64_t = libc::c_long;
pub type __uint64_t = libc::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __int_fast8_t = __int8_t;
pub type __uint_fast8_t = __uint8_t;
pub type __int_fast16_t = libc::c_long;
pub type __uint_fast16_t = libc::c_ulong;
pub type __int_fast32_t = libc::c_long;
pub type __uint_fast32_t = libc::c_ulong;
pub type __int_fast64_t = libc::c_long;
pub type __uint_fast64_t = libc::c_ulong;
pub type __off_t = libc::c_long;
pub type __intptr_t = __int64_t;
pub type __uintptr_t = __uint64_t;
pub type __ptrdiff_t = __int64_t;
pub type __size_t = libc::c_ulong;
pub type __ssize_t = libc::c_long;
pub type __double_t = f64;
pub type __float_t = f32;
pub type __clock_t = libc::c_long;
pub type __time_t = libc::c_long;
pub type __va_list = __builtin_va_list;
pub type __wint_t = libc::c_uint;
pub type __wctype_t = libc::c_ulong;
pub type __wctrans_t = *mut libc::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __c: libc::c_int,
    pub __v: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wc: __wint_t,
    pub __wcb: [libc::c_char; 4usize],
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wcb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wcb)
        )
    );
}
impl Default for __mbstate_t__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::core::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__mbstate_t>())).__c as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__c)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__mbstate_t>())).__v as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__v)
        )
    );
}
impl Default for __mbstate_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type __intmax_t = __int64_t;
pub type __uintmax_t = __uint64_t;
pub type int_least8_t = __int_least8_t;
pub type uint_least8_t = __uint_least8_t;
pub type int_least16_t = __int_least16_t;
pub type uint_least16_t = __uint_least16_t;
pub type int_least32_t = __int_least32_t;
pub type uint_least32_t = __uint_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = __int_fast8_t;
pub type uint_fast8_t = __uint_fast8_t;
pub type int_fast16_t = __int_fast16_t;
pub type uint_fast16_t = __uint_fast16_t;
pub type int_fast32_t = __int_fast32_t;
pub type uint_fast32_t = __uint_fast32_t;
pub type int_fast64_t = __int_fast64_t;
pub type uint_fast64_t = __uint_fast64_t;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type wchar_t = libc::c_int;
pub type mbstate_t = __mbstate_t;
pub type wint_t = __wint_t;
extern "C" {
    pub fn btowc(arg1: libc::c_int) -> wint_t;
}
extern "C" {
    pub fn wctob(arg1: wint_t) -> libc::c_int;
}
extern "C" {
    pub fn mbrlen(arg1: *const libc::c_char, arg2: usize, arg3: *mut mbstate_t) -> usize;
}
extern "C" {
    pub fn mbrtowc(
        arg1: *mut wchar_t,
        arg2: *const libc::c_char,
        arg3: usize,
        arg4: *mut mbstate_t,
    ) -> usize;
}
extern "C" {
    pub fn mbsinit(arg1: *const mbstate_t) -> libc::c_int;
}
extern "C" {
    pub fn mbsrtowcs(
        arg1: *mut wchar_t,
        arg2: *mut *const libc::c_char,
        arg3: usize,
        arg4: *mut mbstate_t,
    ) -> usize;
}
extern "C" {
    pub fn wcrtomb(arg1: *mut libc::c_char, arg2: wchar_t, arg3: *mut mbstate_t) -> usize;
}
extern "C" {
    pub fn wcschr(arg1: *const wchar_t, arg2: wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcscmp(arg1: *const wchar_t, arg2: *const wchar_t) -> libc::c_int;
}
extern "C" {
    pub fn wcscoll(arg1: *const wchar_t, arg2: *const wchar_t) -> libc::c_int;
}
extern "C" {
    pub fn wcscspn(arg1: *const wchar_t, arg2: *const wchar_t) -> usize;
}
extern "C" {
    pub fn wcslen(arg1: *const wchar_t) -> usize;
}
extern "C" {
    pub fn wcsncat(arg1: *mut wchar_t, arg2: *const wchar_t, arg3: usize) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsncmp(arg1: *const wchar_t, arg2: *const wchar_t, arg3: usize) -> libc::c_int;
}
extern "C" {
    pub fn wcsncpy(arg1: *mut wchar_t, arg2: *const wchar_t, arg3: usize) -> *mut wchar_t;
}
extern "C" {
    pub fn wcspbrk(arg1: *const wchar_t, arg2: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsrchr(arg1: *const wchar_t, arg2: wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsrtombs(
        arg1: *mut libc::c_char,
        arg2: *mut *const wchar_t,
        arg3: usize,
        arg4: *mut mbstate_t,
    ) -> usize;
}
extern "C" {
    pub fn wcsspn(arg1: *const wchar_t, arg2: *const wchar_t) -> usize;
}
extern "C" {
    pub fn wcsstr(arg1: *const wchar_t, arg2: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcstok(
        arg1: *mut wchar_t,
        arg2: *const wchar_t,
        arg3: *mut *mut wchar_t,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsxfrm(arg1: *mut wchar_t, arg2: *const wchar_t, arg3: usize) -> usize;
}
extern "C" {
    pub fn wmemchr(arg1: *const wchar_t, arg2: wchar_t, arg3: usize) -> *mut wchar_t;
}
extern "C" {
    pub fn wmemcmp(arg1: *const wchar_t, arg2: *const wchar_t, arg3: usize) -> libc::c_int;
}
extern "C" {
    pub fn wmemcpy(arg1: *mut wchar_t, arg2: *const wchar_t, arg3: usize) -> *mut wchar_t;
}
extern "C" {
    pub fn wmemmove(arg1: *mut wchar_t, arg2: *const wchar_t, arg3: usize) -> *mut wchar_t;
}
extern "C" {
    pub fn wmemset(arg1: *mut wchar_t, arg2: wchar_t, arg3: usize) -> *mut wchar_t;
}
extern "C" {
    pub fn swprintf(arg1: *mut wchar_t, arg2: usize, arg3: *const wchar_t, ...) -> libc::c_int;
}
extern "C" {
    pub fn vswprintf(
        arg1: *mut wchar_t,
        arg2: usize,
        arg3: *const wchar_t,
        arg4: *mut __va_list_tag,
    ) -> libc::c_int;
}
extern "C" {
    pub fn wcswcs(arg1: *const wchar_t, arg2: *const wchar_t) -> *mut wchar_t;
}
pub const SGX_SUCCESS: _status_t = 0;
pub const SGX_ERROR_UNEXPECTED: _status_t = 1;
pub const SGX_ERROR_INVALID_PARAMETER: _status_t = 2;
pub const SGX_ERROR_OUT_OF_MEMORY: _status_t = 3;
pub const SGX_ERROR_ENCLAVE_LOST: _status_t = 4;
pub const SGX_ERROR_INVALID_STATE: _status_t = 5;
pub const SGX_ERROR_FEATURE_NOT_SUPPORTED: _status_t = 8;
pub const SGX_PTHREAD_EXIT: _status_t = 9;
pub const SGX_ERROR_INVALID_FUNCTION: _status_t = 4097;
pub const SGX_ERROR_OUT_OF_TCS: _status_t = 4099;
pub const SGX_ERROR_ENCLAVE_CRASHED: _status_t = 4102;
pub const SGX_ERROR_ECALL_NOT_ALLOWED: _status_t = 4103;
pub const SGX_ERROR_OCALL_NOT_ALLOWED: _status_t = 4104;
pub const SGX_ERROR_STACK_OVERRUN: _status_t = 4105;
pub const SGX_ERROR_UNDEFINED_SYMBOL: _status_t = 8192;
pub const SGX_ERROR_INVALID_ENCLAVE: _status_t = 8193;
pub const SGX_ERROR_INVALID_ENCLAVE_ID: _status_t = 8194;
pub const SGX_ERROR_INVALID_SIGNATURE: _status_t = 8195;
pub const SGX_ERROR_NDEBUG_ENCLAVE: _status_t = 8196;
pub const SGX_ERROR_OUT_OF_EPC: _status_t = 8197;
pub const SGX_ERROR_NO_DEVICE: _status_t = 8198;
pub const SGX_ERROR_MEMORY_MAP_CONFLICT: _status_t = 8199;
pub const SGX_ERROR_INVALID_METADATA: _status_t = 8201;
pub const SGX_ERROR_DEVICE_BUSY: _status_t = 8204;
pub const SGX_ERROR_INVALID_VERSION: _status_t = 8205;
pub const SGX_ERROR_MODE_INCOMPATIBLE: _status_t = 8206;
pub const SGX_ERROR_ENCLAVE_FILE_ACCESS: _status_t = 8207;
pub const SGX_ERROR_INVALID_MISC: _status_t = 8208;
pub const SGX_ERROR_INVALID_LAUNCH_TOKEN: _status_t = 8209;
pub const SGX_ERROR_MAC_MISMATCH: _status_t = 12289;
pub const SGX_ERROR_INVALID_ATTRIBUTE: _status_t = 12290;
pub const SGX_ERROR_INVALID_CPUSVN: _status_t = 12291;
pub const SGX_ERROR_INVALID_ISVSVN: _status_t = 12292;
pub const SGX_ERROR_INVALID_KEYNAME: _status_t = 12293;
pub const SGX_ERROR_SERVICE_UNAVAILABLE: _status_t = 16385;
pub const SGX_ERROR_SERVICE_TIMEOUT: _status_t = 16386;
pub const SGX_ERROR_AE_INVALID_EPIDBLOB: _status_t = 16387;
pub const SGX_ERROR_SERVICE_INVALID_PRIVILEGE: _status_t = 16388;
pub const SGX_ERROR_EPID_MEMBER_REVOKED: _status_t = 16389;
pub const SGX_ERROR_UPDATE_NEEDED: _status_t = 16390;
pub const SGX_ERROR_NETWORK_FAILURE: _status_t = 16391;
pub const SGX_ERROR_AE_SESSION_INVALID: _status_t = 16392;
pub const SGX_ERROR_BUSY: _status_t = 16394;
pub const SGX_ERROR_MC_NOT_FOUND: _status_t = 16396;
pub const SGX_ERROR_MC_NO_ACCESS_RIGHT: _status_t = 16397;
pub const SGX_ERROR_MC_USED_UP: _status_t = 16398;
pub const SGX_ERROR_MC_OVER_QUOTA: _status_t = 16399;
pub const SGX_ERROR_KDF_MISMATCH: _status_t = 16401;
pub const SGX_ERROR_UNRECOGNIZED_PLATFORM: _status_t = 16402;
pub const SGX_ERROR_UNSUPPORTED_CONFIG: _status_t = 16403;
pub const SGX_ERROR_NO_PRIVILEGE: _status_t = 20482;
pub const SGX_ERROR_PCL_ENCRYPTED: _status_t = 24577;
pub const SGX_ERROR_PCL_NOT_ENCRYPTED: _status_t = 24578;
pub const SGX_ERROR_PCL_MAC_MISMATCH: _status_t = 24579;
pub const SGX_ERROR_PCL_SHA_MISMATCH: _status_t = 24580;
pub const SGX_ERROR_PCL_GUID_MISMATCH: _status_t = 24581;
pub const SGX_ERROR_FILE_BAD_STATUS: _status_t = 28673;
pub const SGX_ERROR_FILE_NO_KEY_ID: _status_t = 28674;
pub const SGX_ERROR_FILE_NAME_MISMATCH: _status_t = 28675;
pub const SGX_ERROR_FILE_NOT_SGX_FILE: _status_t = 28676;
pub const SGX_ERROR_FILE_CANT_OPEN_RECOVERY_FILE: _status_t = 28677;
pub const SGX_ERROR_FILE_CANT_WRITE_RECOVERY_FILE: _status_t = 28678;
pub const SGX_ERROR_FILE_RECOVERY_NEEDED: _status_t = 28679;
pub const SGX_ERROR_FILE_FLUSH_FAILED: _status_t = 28680;
pub const SGX_ERROR_FILE_CLOSE_FAILED: _status_t = 28681;
pub const SGX_ERROR_UNSUPPORTED_ATT_KEY_ID: _status_t = 32769;
pub const SGX_ERROR_ATT_KEY_CERTIFICATION_FAILURE: _status_t = 32770;
pub const SGX_ERROR_ATT_KEY_UNINITIALIZED: _status_t = 32771;
pub const SGX_ERROR_INVALID_ATT_KEY_CERT_DATA: _status_t = 32772;
pub const SGX_ERROR_PLATFORM_CERT_UNAVAILABLE: _status_t = 32773;
pub const SGX_INTERNAL_ERROR_ENCLAVE_CREATE_INTERRUPTED: _status_t = 61441;
pub type _status_t = u32;
pub use self::_status_t as sgx_status_t;
pub type sgx_enclave_id_t = u64;
extern "C" {
    pub fn sgx_ocalloc(size: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn sgx_ocfree();
}
extern "C" {
    pub fn sgx_ecall(
        eid: sgx_enclave_id_t,
        index: libc::c_int,
        ocall_table: *const libc::c_void,
        ms: *mut libc::c_void,
    ) -> sgx_status_t;
}
extern "C" {
    pub fn sgx_ecall_switchless(
        eid: sgx_enclave_id_t,
        index: libc::c_int,
        ocall_table: *const libc::c_void,
        ms: *mut libc::c_void,
    ) -> sgx_status_t;
}
extern "C" {
    pub fn sgx_ocall(index: libc::c_uint, ms: *mut libc::c_void) -> sgx_status_t;
}
extern "C" {
    pub fn sgx_ocall_switchless(index: libc::c_uint, ms: *mut libc::c_void) -> sgx_status_t;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct div_t {
    pub quot: libc::c_int,
    pub rem: libc::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(
        ::core::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::core::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<div_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<div_t>())).rem as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct ldiv_t {
    pub quot: libc::c_long,
    pub rem: libc::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(
        ::core::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct lldiv_t {
    pub quot: libc::c_longlong,
    pub rem: libc::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(
        ::core::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn atexit(arg1: ::core::option::Option<unsafe extern "C" fn()>) -> libc::c_int;
}
extern "C" {
    pub fn abs(arg1: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn atof(arg1: *const libc::c_char) -> f64;
}
extern "C" {
    pub fn atoi(arg1: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn atol(arg1: *const libc::c_char) -> libc::c_long;
}
extern "C" {
    pub fn bsearch(
        arg1: *const libc::c_void,
        arg2: *const libc::c_void,
        arg3: usize,
        arg4: usize,
        arg5: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const libc::c_void,
                arg2: *const libc::c_void,
            ) -> libc::c_int,
        >,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn calloc(arg1: usize, arg2: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn div(arg1: libc::c_int, arg2: libc::c_int) -> div_t;
}
extern "C" {
    pub fn free(arg1: *mut libc::c_void);
}
extern "C" {
    pub fn labs(arg1: libc::c_long) -> libc::c_long;
}
extern "C" {
    pub fn ldiv(arg1: libc::c_long, arg2: libc::c_long) -> ldiv_t;
}
extern "C" {
    pub fn malloc(arg1: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn memalign(arg1: usize, arg2: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn qsort(
        arg1: *mut libc::c_void,
        arg2: usize,
        arg3: usize,
        arg4: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const libc::c_void,
                arg2: *const libc::c_void,
            ) -> libc::c_int,
        >,
    );
}
extern "C" {
    pub fn realloc(arg1: *mut libc::c_void, arg2: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn strtod(arg1: *const libc::c_char, arg2: *mut *mut libc::c_char) -> f64;
}
extern "C" {
    pub fn strtol(
        arg1: *const libc::c_char,
        arg2: *mut *mut libc::c_char,
        arg3: libc::c_int,
    ) -> libc::c_long;
}
extern "C" {
    pub fn strtof(arg1: *const libc::c_char, arg2: *mut *mut libc::c_char) -> f32;
}
extern "C" {
    pub fn atoll(arg1: *const libc::c_char) -> libc::c_longlong;
}
extern "C" {
    pub fn llabs(arg1: libc::c_longlong) -> libc::c_longlong;
}
extern "C" {
    pub fn lldiv(arg1: libc::c_longlong, arg2: libc::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn strtoll(
        arg1: *const libc::c_char,
        arg2: *mut *mut libc::c_char,
        arg3: libc::c_int,
    ) -> libc::c_longlong;
}
extern "C" {
    pub fn strtoul(
        arg1: *const libc::c_char,
        arg2: *mut *mut libc::c_char,
        arg3: libc::c_int,
    ) -> libc::c_ulong;
}
extern "C" {
    pub fn strtold(arg1: *const libc::c_char, arg2: *mut *mut libc::c_char) -> u128;
}
extern "C" {
    pub fn strtoull(
        arg1: *const libc::c_char,
        arg2: *mut *mut libc::c_char,
        arg3: libc::c_int,
    ) -> libc::c_ulonglong;
}
extern "C" {
    pub fn mblen(arg1: *const libc::c_char, arg2: usize) -> libc::c_int;
}
extern "C" {
    pub fn mbstowcs(arg1: *mut wchar_t, arg2: *const libc::c_char, arg3: usize) -> usize;
}
extern "C" {
    pub fn wctomb(arg1: *mut libc::c_char, arg2: wchar_t) -> libc::c_int;
}
extern "C" {
    pub fn mbtowc(arg1: *mut wchar_t, arg2: *const libc::c_char, arg3: usize) -> libc::c_int;
}
extern "C" {
    pub fn wcstombs(arg1: *mut libc::c_char, arg2: *const wchar_t, arg3: usize) -> usize;
}
extern "C" {
    pub fn alloca(arg1: usize) -> *mut libc::c_void;
}
pub type va_list = __va_list;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _attributes_t {
    pub flags: u64,
    pub xfrm: u64,
}
#[test]
fn bindgen_test_layout__attributes_t() {
    assert_eq!(
        ::core::mem::size_of::<_attributes_t>(),
        16usize,
        concat!("Size of: ", stringify!(_attributes_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_attributes_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_attributes_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_attributes_t>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_attributes_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_attributes_t>())).xfrm as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_attributes_t),
            "::",
            stringify!(xfrm)
        )
    );
}
pub type sgx_attributes_t = _attributes_t;
pub type sgx_misc_select_t = u32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _sgx_misc_attribute_t {
    pub secs_attr: sgx_attributes_t,
    pub misc_select: sgx_misc_select_t,
}
#[test]
fn bindgen_test_layout__sgx_misc_attribute_t() {
    assert_eq!(
        ::core::mem::size_of::<_sgx_misc_attribute_t>(),
        24usize,
        concat!("Size of: ", stringify!(_sgx_misc_attribute_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_sgx_misc_attribute_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_sgx_misc_attribute_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_sgx_misc_attribute_t>())).secs_attr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_sgx_misc_attribute_t),
            "::",
            stringify!(secs_attr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_sgx_misc_attribute_t>())).misc_select as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_sgx_misc_attribute_t),
            "::",
            stringify!(misc_select)
        )
    );
}
pub type sgx_misc_attribute_t = _sgx_misc_attribute_t;
pub type sgx_key_128bit_t = [u8; 16usize];
pub type sgx_isv_svn_t = u16;
pub type sgx_config_svn_t = u16;
pub type sgx_config_id_t = [u8; 64usize];
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _sgx_cpu_svn_t {
    pub svn: [u8; 16usize],
}
#[test]
fn bindgen_test_layout__sgx_cpu_svn_t() {
    assert_eq!(
        ::core::mem::size_of::<_sgx_cpu_svn_t>(),
        16usize,
        concat!("Size of: ", stringify!(_sgx_cpu_svn_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_sgx_cpu_svn_t>(),
        1usize,
        concat!("Alignment of ", stringify!(_sgx_cpu_svn_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_sgx_cpu_svn_t>())).svn as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_sgx_cpu_svn_t),
            "::",
            stringify!(svn)
        )
    );
}
pub type sgx_cpu_svn_t = _sgx_cpu_svn_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _sgx_key_id_t {
    pub id: [u8; 32usize],
}
#[test]
fn bindgen_test_layout__sgx_key_id_t() {
    assert_eq!(
        ::core::mem::size_of::<_sgx_key_id_t>(),
        32usize,
        concat!("Size of: ", stringify!(_sgx_key_id_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_sgx_key_id_t>(),
        1usize,
        concat!("Alignment of ", stringify!(_sgx_key_id_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_sgx_key_id_t>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_sgx_key_id_t),
            "::",
            stringify!(id)
        )
    );
}
pub type sgx_key_id_t = _sgx_key_id_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _key_request_t {
    pub key_name: u16,
    pub key_policy: u16,
    pub isv_svn: sgx_isv_svn_t,
    pub reserved1: u16,
    pub cpu_svn: sgx_cpu_svn_t,
    pub attribute_mask: sgx_attributes_t,
    pub key_id: sgx_key_id_t,
    pub misc_mask: sgx_misc_select_t,
    pub config_svn: sgx_config_svn_t,
    pub reserved2: [u8; 434usize],
}
#[test]
fn bindgen_test_layout__key_request_t() {
    assert_eq!(
        ::core::mem::size_of::<_key_request_t>(),
        512usize,
        concat!("Size of: ", stringify!(_key_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_key_request_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_key_request_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_key_request_t>())).key_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_key_request_t),
            "::",
            stringify!(key_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_key_request_t>())).key_policy as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_key_request_t),
            "::",
            stringify!(key_policy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_key_request_t>())).isv_svn as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_key_request_t),
            "::",
            stringify!(isv_svn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_key_request_t>())).reserved1 as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_key_request_t),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_key_request_t>())).cpu_svn as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_key_request_t),
            "::",
            stringify!(cpu_svn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_key_request_t>())).attribute_mask as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_key_request_t),
            "::",
            stringify!(attribute_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_key_request_t>())).key_id as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_key_request_t),
            "::",
            stringify!(key_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_key_request_t>())).misc_mask as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_key_request_t),
            "::",
            stringify!(misc_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_key_request_t>())).config_svn as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_key_request_t),
            "::",
            stringify!(config_svn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_key_request_t>())).reserved2 as *const _ as usize },
        78usize,
        concat!(
            "Offset of field: ",
            stringify!(_key_request_t),
            "::",
            stringify!(reserved2)
        )
    );
}
impl Default for _key_request_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type sgx_key_request_t = _key_request_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _sgx_measurement_t {
    pub m: [u8; 32usize],
}
#[test]
fn bindgen_test_layout__sgx_measurement_t() {
    assert_eq!(
        ::core::mem::size_of::<_sgx_measurement_t>(),
        32usize,
        concat!("Size of: ", stringify!(_sgx_measurement_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_sgx_measurement_t>(),
        1usize,
        concat!("Alignment of ", stringify!(_sgx_measurement_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_sgx_measurement_t>())).m as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_sgx_measurement_t),
            "::",
            stringify!(m)
        )
    );
}
pub type sgx_measurement_t = _sgx_measurement_t;
pub type sgx_mac_t = [u8; 16usize];
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _sgx_report_data_t {
    pub d: [u8; 64usize],
}
#[test]
fn bindgen_test_layout__sgx_report_data_t() {
    assert_eq!(
        ::core::mem::size_of::<_sgx_report_data_t>(),
        64usize,
        concat!("Size of: ", stringify!(_sgx_report_data_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_sgx_report_data_t>(),
        1usize,
        concat!("Alignment of ", stringify!(_sgx_report_data_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_sgx_report_data_t>())).d as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_sgx_report_data_t),
            "::",
            stringify!(d)
        )
    );
}
impl Default for _sgx_report_data_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type sgx_report_data_t = _sgx_report_data_t;
pub type sgx_prod_id_t = u16;
pub type sgx_isvext_prod_id_t = [u8; 16usize];
pub type sgx_isvfamily_id_t = [u8; 16usize];
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _target_info_t {
    pub mr_enclave: sgx_measurement_t,
    pub attributes: sgx_attributes_t,
    pub reserved1: [u8; 2usize],
    pub config_svn: sgx_config_svn_t,
    pub misc_select: sgx_misc_select_t,
    pub reserved2: [u8; 8usize],
    pub config_id: sgx_config_id_t,
    pub reserved3: [u8; 384usize],
}
#[test]
fn bindgen_test_layout__target_info_t() {
    assert_eq!(
        ::core::mem::size_of::<_target_info_t>(),
        512usize,
        concat!("Size of: ", stringify!(_target_info_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_target_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_target_info_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_target_info_t>())).mr_enclave as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_target_info_t),
            "::",
            stringify!(mr_enclave)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_target_info_t>())).attributes as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_target_info_t),
            "::",
            stringify!(attributes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_target_info_t>())).reserved1 as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_target_info_t),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_target_info_t>())).config_svn as *const _ as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(_target_info_t),
            "::",
            stringify!(config_svn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_target_info_t>())).misc_select as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_target_info_t),
            "::",
            stringify!(misc_select)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_target_info_t>())).reserved2 as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_target_info_t),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_target_info_t>())).config_id as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_target_info_t),
            "::",
            stringify!(config_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_target_info_t>())).reserved3 as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_target_info_t),
            "::",
            stringify!(reserved3)
        )
    );
}
impl Default for _target_info_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type sgx_target_info_t = _target_info_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _report_body_t {
    pub cpu_svn: sgx_cpu_svn_t,
    pub misc_select: sgx_misc_select_t,
    pub reserved1: [u8; 12usize],
    pub isv_ext_prod_id: sgx_isvext_prod_id_t,
    pub attributes: sgx_attributes_t,
    pub mr_enclave: sgx_measurement_t,
    pub reserved2: [u8; 32usize],
    pub mr_signer: sgx_measurement_t,
    pub reserved3: [u8; 32usize],
    pub config_id: sgx_config_id_t,
    pub isv_prod_id: sgx_prod_id_t,
    pub isv_svn: sgx_isv_svn_t,
    pub config_svn: sgx_config_svn_t,
    pub reserved4: [u8; 42usize],
    pub isv_family_id: sgx_isvfamily_id_t,
    pub report_data: sgx_report_data_t,
}
#[test]
fn bindgen_test_layout__report_body_t() {
    assert_eq!(
        ::core::mem::size_of::<_report_body_t>(),
        384usize,
        concat!("Size of: ", stringify!(_report_body_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_report_body_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_report_body_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_report_body_t>())).cpu_svn as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_report_body_t),
            "::",
            stringify!(cpu_svn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_report_body_t>())).misc_select as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_report_body_t),
            "::",
            stringify!(misc_select)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_report_body_t>())).reserved1 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_report_body_t),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_report_body_t>())).isv_ext_prod_id as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_report_body_t),
            "::",
            stringify!(isv_ext_prod_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_report_body_t>())).attributes as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_report_body_t),
            "::",
            stringify!(attributes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_report_body_t>())).mr_enclave as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_report_body_t),
            "::",
            stringify!(mr_enclave)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_report_body_t>())).reserved2 as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_report_body_t),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_report_body_t>())).mr_signer as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_report_body_t),
            "::",
            stringify!(mr_signer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_report_body_t>())).reserved3 as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_report_body_t),
            "::",
            stringify!(reserved3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_report_body_t>())).config_id as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_report_body_t),
            "::",
            stringify!(config_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_report_body_t>())).isv_prod_id as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_report_body_t),
            "::",
            stringify!(isv_prod_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_report_body_t>())).isv_svn as *const _ as usize },
        258usize,
        concat!(
            "Offset of field: ",
            stringify!(_report_body_t),
            "::",
            stringify!(isv_svn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_report_body_t>())).config_svn as *const _ as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(_report_body_t),
            "::",
            stringify!(config_svn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_report_body_t>())).reserved4 as *const _ as usize },
        262usize,
        concat!(
            "Offset of field: ",
            stringify!(_report_body_t),
            "::",
            stringify!(reserved4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_report_body_t>())).isv_family_id as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(_report_body_t),
            "::",
            stringify!(isv_family_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_report_body_t>())).report_data as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(_report_body_t),
            "::",
            stringify!(report_data)
        )
    );
}
impl Default for _report_body_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type sgx_report_body_t = _report_body_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _report_t {
    pub body: sgx_report_body_t,
    pub key_id: sgx_key_id_t,
    pub mac: sgx_mac_t,
}
#[test]
fn bindgen_test_layout__report_t() {
    assert_eq!(
        ::core::mem::size_of::<_report_t>(),
        432usize,
        concat!("Size of: ", stringify!(_report_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_report_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_report_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_report_t>())).body as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_report_t),
            "::",
            stringify!(body)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_report_t>())).key_id as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(_report_t),
            "::",
            stringify!(key_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_report_t>())).mac as *const _ as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(_report_t),
            "::",
            stringify!(mac)
        )
    );
}
impl Default for _report_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type sgx_report_t = _report_t;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _sgx_kss_config_t {
    pub config_id: sgx_config_id_t,
    pub config_svn: sgx_config_svn_t,
}
#[test]
fn bindgen_test_layout__sgx_kss_config_t() {
    assert_eq!(
        ::core::mem::size_of::<_sgx_kss_config_t>(),
        66usize,
        concat!("Size of: ", stringify!(_sgx_kss_config_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_sgx_kss_config_t>(),
        1usize,
        concat!("Alignment of ", stringify!(_sgx_kss_config_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_sgx_kss_config_t>())).config_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_sgx_kss_config_t),
            "::",
            stringify!(config_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_sgx_kss_config_t>())).config_svn as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_sgx_kss_config_t),
            "::",
            stringify!(config_svn)
        )
    );
}
impl Default for _sgx_kss_config_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type sgx_kss_config_t = _sgx_kss_config_t;
pub type sgx_launch_token_t = [u8; 1024usize];
extern "C" {
    pub fn sgx_create_enclave(
        file_name: *const libc::c_char,
        debug: libc::c_int,
        launch_token: *mut sgx_launch_token_t,
        launch_token_updated: *mut libc::c_int,
        enclave_id: *mut sgx_enclave_id_t,
        misc_attr: *mut sgx_misc_attribute_t,
    ) -> sgx_status_t;
}
extern "C" {
    pub fn sgx_create_enclave_ex(
        file_name: *const libc::c_char,
        debug: libc::c_int,
        launch_token: *mut sgx_launch_token_t,
        launch_token_updated: *mut libc::c_int,
        enclave_id: *mut sgx_enclave_id_t,
        misc_attr: *mut sgx_misc_attribute_t,
        ex_features: u32,
        ex_features_p: *mut *const libc::c_void,
    ) -> sgx_status_t;
}
extern "C" {
    pub fn sgx_create_enclave_from_buffer_ex(
        buffer: *mut u8,
        buffer_size: usize,
        debug: libc::c_int,
        enclave_id: *mut sgx_enclave_id_t,
        misc_attr: *mut sgx_misc_attribute_t,
        ex_features: u32,
        ex_features_p: *mut *const libc::c_void,
    ) -> sgx_status_t;
}
extern "C" {
    pub fn sgx_create_encrypted_enclave(
        file_name: *const libc::c_char,
        debug: libc::c_int,
        launch_token: *mut sgx_launch_token_t,
        launch_token_updated: *mut libc::c_int,
        enclave_id: *mut sgx_enclave_id_t,
        misc_attr: *mut sgx_misc_attribute_t,
        sealed_key: *mut u8,
    ) -> sgx_status_t;
}
extern "C" {
    pub fn sgx_destroy_enclave(enclave_id: sgx_enclave_id_t) -> sgx_status_t;
}
extern "C" {
    pub fn sgx_get_target_info(
        enclave_id: sgx_enclave_id_t,
        target_info: *mut sgx_target_info_t,
    ) -> sgx_status_t;
}
pub type sgx_epid_group_id_t = [u8; 4usize];
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _spid_t {
    pub id: [u8; 16usize],
}
#[test]
fn bindgen_test_layout__spid_t() {
    assert_eq!(
        ::core::mem::size_of::<_spid_t>(),
        16usize,
        concat!("Size of: ", stringify!(_spid_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_spid_t>(),
        1usize,
        concat!("Alignment of ", stringify!(_spid_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_spid_t>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_spid_t),
            "::",
            stringify!(id)
        )
    );
}
pub type sgx_spid_t = _spid_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _basename_t {
    pub name: [u8; 32usize],
}
#[test]
fn bindgen_test_layout__basename_t() {
    assert_eq!(
        ::core::mem::size_of::<_basename_t>(),
        32usize,
        concat!("Size of: ", stringify!(_basename_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_basename_t>(),
        1usize,
        concat!("Alignment of ", stringify!(_basename_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_basename_t>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_basename_t),
            "::",
            stringify!(name)
        )
    );
}
pub type sgx_basename_t = _basename_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _quote_nonce {
    pub rand: [u8; 16usize],
}
#[test]
fn bindgen_test_layout__quote_nonce() {
    assert_eq!(
        ::core::mem::size_of::<_quote_nonce>(),
        16usize,
        concat!("Size of: ", stringify!(_quote_nonce))
    );
    assert_eq!(
        ::core::mem::align_of::<_quote_nonce>(),
        1usize,
        concat!("Alignment of ", stringify!(_quote_nonce))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_quote_nonce>())).rand as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_quote_nonce),
            "::",
            stringify!(rand)
        )
    );
}
pub type sgx_quote_nonce_t = _quote_nonce;
pub const SGX_UNLINKABLE_SIGNATURE: sgx_quote_sign_type_t = 0;
pub const SGX_LINKABLE_SIGNATURE: sgx_quote_sign_type_t = 1;
pub type sgx_quote_sign_type_t = u32;
#[repr(C, packed)]
pub struct _quote_t {
    pub version: u16,
    pub sign_type: u16,
    pub epid_group_id: sgx_epid_group_id_t,
    pub qe_svn: sgx_isv_svn_t,
    pub pce_svn: sgx_isv_svn_t,
    pub xeid: u32,
    pub basename: sgx_basename_t,
    pub report_body: sgx_report_body_t,
    pub signature_len: u32,
    pub signature: __IncompleteArrayField<u8>,
}
#[test]
fn bindgen_test_layout__quote_t() {
    assert_eq!(
        ::core::mem::size_of::<_quote_t>(),
        436usize,
        concat!("Size of: ", stringify!(_quote_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_quote_t>(),
        1usize,
        concat!("Alignment of ", stringify!(_quote_t))
    );
}
impl Default for _quote_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type sgx_quote_t = _quote_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _platform_info {
    pub platform_info: [u8; 101usize],
}
#[test]
fn bindgen_test_layout__platform_info() {
    assert_eq!(
        ::core::mem::size_of::<_platform_info>(),
        101usize,
        concat!("Size of: ", stringify!(_platform_info))
    );
    assert_eq!(
        ::core::mem::align_of::<_platform_info>(),
        1usize,
        concat!("Alignment of ", stringify!(_platform_info))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_platform_info>())).platform_info as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_platform_info),
            "::",
            stringify!(platform_info)
        )
    );
}
impl Default for _platform_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type sgx_platform_info_t = _platform_info;
#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct _update_info_bit {
    pub ucodeUpdate: libc::c_int,
    pub csmeFwUpdate: libc::c_int,
    pub pswUpdate: libc::c_int,
}
#[test]
fn bindgen_test_layout__update_info_bit() {
    assert_eq!(
        ::core::mem::size_of::<_update_info_bit>(),
        12usize,
        concat!("Size of: ", stringify!(_update_info_bit))
    );
    assert_eq!(
        ::core::mem::align_of::<_update_info_bit>(),
        1usize,
        concat!("Alignment of ", stringify!(_update_info_bit))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_update_info_bit>())).ucodeUpdate as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_update_info_bit),
            "::",
            stringify!(ucodeUpdate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_update_info_bit>())).csmeFwUpdate as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_update_info_bit),
            "::",
            stringify!(csmeFwUpdate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_update_info_bit>())).pswUpdate as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_update_info_bit),
            "::",
            stringify!(pswUpdate)
        )
    );
}
pub type sgx_update_info_bit_t = _update_info_bit;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _att_key_id_t {
    pub att_key_id: [u8; 256usize],
}
#[test]
fn bindgen_test_layout__att_key_id_t() {
    assert_eq!(
        ::core::mem::size_of::<_att_key_id_t>(),
        256usize,
        concat!("Size of: ", stringify!(_att_key_id_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_att_key_id_t>(),
        1usize,
        concat!("Alignment of ", stringify!(_att_key_id_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_att_key_id_t>())).att_key_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_att_key_id_t),
            "::",
            stringify!(att_key_id)
        )
    );
}
impl Default for _att_key_id_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type sgx_att_key_id_t = _att_key_id_t;
#[doc = " Describes a single attestation key.  Contains both QE identity and the attestation algorithm ID."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _sgx_ql_att_key_id_t {
    #[doc = "< Structure ID"]
    pub id: u16,
    #[doc = "< Structure version"]
    pub version: u16,
    #[doc = "< Number of valid bytes in MRSIGNER."]
    pub mrsigner_length: u16,
    #[doc = "< SHA256 or SHA384 hash of the Public key that signed the QE."]
    #[doc = "< The lower bytes contain MRSIGNER.  Bytes beyond mrsigner_length '0'"]
    pub mrsigner: [u8; 48usize],
    #[doc = "< Legacy Product ID of the QE"]
    pub prod_id: u32,
    #[doc = "< Extended Product ID or the QE. All 0's for legacy format enclaves."]
    pub extended_prod_id: [u8; 16usize],
    #[doc = "< Config ID of the QE."]
    pub config_id: [u8; 64usize],
    #[doc = "< Family ID of the QE."]
    pub family_id: [u8; 16usize],
    #[doc = "< Identity of the attestation key algorithm."]
    pub algorithm_id: u32,
}
#[test]
fn bindgen_test_layout__sgx_ql_att_key_id_t() {
    assert_eq!(
        ::core::mem::size_of::<_sgx_ql_att_key_id_t>(),
        158usize,
        concat!("Size of: ", stringify!(_sgx_ql_att_key_id_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_sgx_ql_att_key_id_t>(),
        1usize,
        concat!("Alignment of ", stringify!(_sgx_ql_att_key_id_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_sgx_ql_att_key_id_t>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_sgx_ql_att_key_id_t),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_sgx_ql_att_key_id_t>())).version as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_sgx_ql_att_key_id_t),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_sgx_ql_att_key_id_t>())).mrsigner_length as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_sgx_ql_att_key_id_t),
            "::",
            stringify!(mrsigner_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_sgx_ql_att_key_id_t>())).mrsigner as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_sgx_ql_att_key_id_t),
            "::",
            stringify!(mrsigner)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_sgx_ql_att_key_id_t>())).prod_id as *const _ as usize },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(_sgx_ql_att_key_id_t),
            "::",
            stringify!(prod_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_sgx_ql_att_key_id_t>())).extended_prod_id as *const _ as usize
        },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(_sgx_ql_att_key_id_t),
            "::",
            stringify!(extended_prod_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_sgx_ql_att_key_id_t>())).config_id as *const _ as usize },
        74usize,
        concat!(
            "Offset of field: ",
            stringify!(_sgx_ql_att_key_id_t),
            "::",
            stringify!(config_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_sgx_ql_att_key_id_t>())).family_id as *const _ as usize },
        138usize,
        concat!(
            "Offset of field: ",
            stringify!(_sgx_ql_att_key_id_t),
            "::",
            stringify!(family_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_sgx_ql_att_key_id_t>())).algorithm_id as *const _ as usize
        },
        154usize,
        concat!(
            "Offset of field: ",
            stringify!(_sgx_ql_att_key_id_t),
            "::",
            stringify!(algorithm_id)
        )
    );
}
impl Default for _sgx_ql_att_key_id_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type sgx_ql_att_key_id_t = _sgx_ql_att_key_id_t;
#[doc = " Describes an extended attestation key.  Contains sgx_ql_att_key_id_t, spid and quote_type"]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _sgx_att_key_id_ext_t {
    pub base: sgx_ql_att_key_id_t,
    #[doc = "< Service Provider ID, should be 0s for ECDSA quote"]
    pub spid: [u8; 16usize],
    #[doc = "< For non-EPID quote, it should be 0"]
    #[doc = "< For EPID quote, it equals to sgx_quote_sign_type_t"]
    pub att_key_type: u16,
    #[doc = "< It should have the same size of sgx_att_key_id_t"]
    pub reserved: [u8; 80usize],
}
#[test]
fn bindgen_test_layout__sgx_att_key_id_ext_t() {
    assert_eq!(
        ::core::mem::size_of::<_sgx_att_key_id_ext_t>(),
        256usize,
        concat!("Size of: ", stringify!(_sgx_att_key_id_ext_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_sgx_att_key_id_ext_t>(),
        1usize,
        concat!("Alignment of ", stringify!(_sgx_att_key_id_ext_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_sgx_att_key_id_ext_t>())).base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_sgx_att_key_id_ext_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_sgx_att_key_id_ext_t>())).spid as *const _ as usize },
        158usize,
        concat!(
            "Offset of field: ",
            stringify!(_sgx_att_key_id_ext_t),
            "::",
            stringify!(spid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_sgx_att_key_id_ext_t>())).att_key_type as *const _ as usize
        },
        174usize,
        concat!(
            "Offset of field: ",
            stringify!(_sgx_att_key_id_ext_t),
            "::",
            stringify!(att_key_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_sgx_att_key_id_ext_t>())).reserved as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_sgx_att_key_id_ext_t),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for _sgx_att_key_id_ext_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type sgx_att_key_id_ext_t = _sgx_att_key_id_ext_t;
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct _qe_report_info_t {
    pub nonce: sgx_quote_nonce_t,
    pub app_enclave_target_info: sgx_target_info_t,
    pub qe_report: sgx_report_t,
}
#[test]
fn bindgen_test_layout__qe_report_info_t() {
    assert_eq!(
        ::core::mem::size_of::<_qe_report_info_t>(),
        960usize,
        concat!("Size of: ", stringify!(_qe_report_info_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_qe_report_info_t>(),
        1usize,
        concat!("Alignment of ", stringify!(_qe_report_info_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_qe_report_info_t>())).nonce as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_qe_report_info_t),
            "::",
            stringify!(nonce)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_qe_report_info_t>())).app_enclave_target_info as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_qe_report_info_t),
            "::",
            stringify!(app_enclave_target_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_qe_report_info_t>())).qe_report as *const _ as usize },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(_qe_report_info_t),
            "::",
            stringify!(qe_report)
        )
    );
}
impl Default for _qe_report_info_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type sgx_qe_report_info_t = _qe_report_info_t;
pub type sgxsd_aes_gcm_mac_t = sgxsd_aes_gcm_mac;
pub type sgxsd_aes_gcm_iv_t = sgxsd_aes_gcm_iv;
pub type sgxsd_aes_gcm_key_t = sgxsd_aes_gcm_key;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct sgxsd_curve25519_public_key {
    pub x: [u8; 32usize],
}
#[test]
fn bindgen_test_layout_sgxsd_curve25519_public_key() {
    assert_eq!(
        ::core::mem::size_of::<sgxsd_curve25519_public_key>(),
        32usize,
        concat!("Size of: ", stringify!(sgxsd_curve25519_public_key))
    );
    assert_eq!(
        ::core::mem::align_of::<sgxsd_curve25519_public_key>(),
        1usize,
        concat!("Alignment of ", stringify!(sgxsd_curve25519_public_key))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sgxsd_curve25519_public_key>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sgxsd_curve25519_public_key),
            "::",
            stringify!(x)
        )
    );
}
pub type sgxsd_curve25519_public_key_t = sgxsd_curve25519_public_key;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct sgxsd_request_negotiation_request {
    pub client_pubkey: sgxsd_curve25519_public_key_t,
}
#[test]
fn bindgen_test_layout_sgxsd_request_negotiation_request() {
    assert_eq!(
        ::core::mem::size_of::<sgxsd_request_negotiation_request>(),
        32usize,
        concat!("Size of: ", stringify!(sgxsd_request_negotiation_request))
    );
    assert_eq!(
        ::core::mem::align_of::<sgxsd_request_negotiation_request>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sgxsd_request_negotiation_request)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sgxsd_request_negotiation_request>())).client_pubkey as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sgxsd_request_negotiation_request),
            "::",
            stringify!(client_pubkey)
        )
    );
}
pub type sgxsd_request_negotiation_request_t = sgxsd_request_negotiation_request;
#[repr(C)]
pub struct sgxsd_pending_request_id {
    pub data: [u8; 8usize],
    pub iv: sgxsd_aes_gcm_iv_t,
    pub mac: sgxsd_aes_gcm_mac_t,
}
#[test]
fn bindgen_test_layout_sgxsd_pending_request_id() {
    assert_eq!(
        ::core::mem::size_of::<sgxsd_pending_request_id>(),
        36usize,
        concat!("Size of: ", stringify!(sgxsd_pending_request_id))
    );
    assert_eq!(
        ::core::mem::align_of::<sgxsd_pending_request_id>(),
        1usize,
        concat!("Alignment of ", stringify!(sgxsd_pending_request_id))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sgxsd_pending_request_id>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sgxsd_pending_request_id),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sgxsd_pending_request_id>())).iv as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sgxsd_pending_request_id),
            "::",
            stringify!(iv)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sgxsd_pending_request_id>())).mac as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(sgxsd_pending_request_id),
            "::",
            stringify!(mac)
        )
    );
}
impl Default for sgxsd_pending_request_id {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type sgxsd_pending_request_id_t = sgxsd_pending_request_id;
#[repr(C)]
pub struct sgxsd_request_negotiation_response {
    pub server_static_pubkey: sgxsd_curve25519_public_key_t,
    pub server_ephemeral_pubkey: sgxsd_curve25519_public_key_t,
    pub encrypted_pending_request_id: sgxsd_request_negotiation_response__bindgen_ty_1,
}
#[repr(C)]
pub struct sgxsd_request_negotiation_response__bindgen_ty_1 {
    pub data: [u8; 36usize],
    pub iv: sgxsd_aes_gcm_iv_t,
    pub mac: sgxsd_aes_gcm_mac_t,
}
#[test]
fn bindgen_test_layout_sgxsd_request_negotiation_response__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<sgxsd_request_negotiation_response__bindgen_ty_1>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(sgxsd_request_negotiation_response__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sgxsd_request_negotiation_response__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sgxsd_request_negotiation_response__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sgxsd_request_negotiation_response__bindgen_ty_1>())).data
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sgxsd_request_negotiation_response__bindgen_ty_1),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sgxsd_request_negotiation_response__bindgen_ty_1>())).iv
                as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(sgxsd_request_negotiation_response__bindgen_ty_1),
            "::",
            stringify!(iv)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sgxsd_request_negotiation_response__bindgen_ty_1>())).mac
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sgxsd_request_negotiation_response__bindgen_ty_1),
            "::",
            stringify!(mac)
        )
    );
}
impl Default for sgxsd_request_negotiation_response__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_sgxsd_request_negotiation_response() {
    assert_eq!(
        ::core::mem::size_of::<sgxsd_request_negotiation_response>(),
        128usize,
        concat!("Size of: ", stringify!(sgxsd_request_negotiation_response))
    );
    assert_eq!(
        ::core::mem::align_of::<sgxsd_request_negotiation_response>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sgxsd_request_negotiation_response)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sgxsd_request_negotiation_response>())).server_static_pubkey
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sgxsd_request_negotiation_response),
            "::",
            stringify!(server_static_pubkey)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sgxsd_request_negotiation_response>())).server_ephemeral_pubkey
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sgxsd_request_negotiation_response),
            "::",
            stringify!(server_ephemeral_pubkey)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sgxsd_request_negotiation_response>()))
                .encrypted_pending_request_id as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sgxsd_request_negotiation_response),
            "::",
            stringify!(encrypted_pending_request_id)
        )
    );
}
impl Default for sgxsd_request_negotiation_response {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type sgxsd_request_negotiation_response_t = sgxsd_request_negotiation_response;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sgxsd_msg_tag {
    pub __bindgen_anon_1: sgxsd_msg_tag__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sgxsd_msg_tag__bindgen_ty_1 {
    pub p_tag: *mut libc::c_void,
    pub tag: u64,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_sgxsd_msg_tag__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<sgxsd_msg_tag__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(sgxsd_msg_tag__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<sgxsd_msg_tag__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(sgxsd_msg_tag__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sgxsd_msg_tag__bindgen_ty_1>())).p_tag as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sgxsd_msg_tag__bindgen_ty_1),
            "::",
            stringify!(p_tag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sgxsd_msg_tag__bindgen_ty_1>())).tag as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sgxsd_msg_tag__bindgen_ty_1),
            "::",
            stringify!(tag)
        )
    );
}
impl Default for sgxsd_msg_tag__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_sgxsd_msg_tag() {
    assert_eq!(
        ::core::mem::size_of::<sgxsd_msg_tag>(),
        8usize,
        concat!("Size of: ", stringify!(sgxsd_msg_tag))
    );
    assert_eq!(
        ::core::mem::align_of::<sgxsd_msg_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(sgxsd_msg_tag))
    );
}
impl Default for sgxsd_msg_tag {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type sgxsd_msg_tag_t = sgxsd_msg_tag;
#[repr(C)]
pub struct sgxsd_msg_header {
    pub iv: sgxsd_aes_gcm_iv_t,
    pub mac: sgxsd_aes_gcm_mac_t,
    pub pending_request_id: sgxsd_pending_request_id_t,
}
#[test]
fn bindgen_test_layout_sgxsd_msg_header() {
    assert_eq!(
        ::core::mem::size_of::<sgxsd_msg_header>(),
        64usize,
        concat!("Size of: ", stringify!(sgxsd_msg_header))
    );
    assert_eq!(
        ::core::mem::align_of::<sgxsd_msg_header>(),
        1usize,
        concat!("Alignment of ", stringify!(sgxsd_msg_header))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sgxsd_msg_header>())).iv as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sgxsd_msg_header),
            "::",
            stringify!(iv)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sgxsd_msg_header>())).mac as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sgxsd_msg_header),
            "::",
            stringify!(mac)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sgxsd_msg_header>())).pending_request_id as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(sgxsd_msg_header),
            "::",
            stringify!(pending_request_id)
        )
    );
}
impl Default for sgxsd_msg_header {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type sgxsd_msg_header_t = sgxsd_msg_header;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct sgxsd_node_init_args {
    pub pending_requests_table_order: u8,
}
#[test]
fn bindgen_test_layout_sgxsd_node_init_args() {
    assert_eq!(
        ::core::mem::size_of::<sgxsd_node_init_args>(),
        1usize,
        concat!("Size of: ", stringify!(sgxsd_node_init_args))
    );
    assert_eq!(
        ::core::mem::align_of::<sgxsd_node_init_args>(),
        1usize,
        concat!("Alignment of ", stringify!(sgxsd_node_init_args))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sgxsd_node_init_args>())).pending_requests_table_order
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sgxsd_node_init_args),
            "::",
            stringify!(pending_requests_table_order)
        )
    );
}
pub type sgxsd_node_init_args_t = sgxsd_node_init_args;
pub type sgxsd_server_state_handle_t = u64;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct sgxsd_status {
    pub ok: bool,
    pub name: *const libc::c_char,
    pub code: i64,
}
#[test]
fn bindgen_test_layout_sgxsd_status() {
    assert_eq!(
        ::core::mem::size_of::<sgxsd_status>(),
        24usize,
        concat!("Size of: ", stringify!(sgxsd_status))
    );
    assert_eq!(
        ::core::mem::align_of::<sgxsd_status>(),
        8usize,
        concat!("Alignment of ", stringify!(sgxsd_status))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sgxsd_status>())).ok as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sgxsd_status),
            "::",
            stringify!(ok)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sgxsd_status>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sgxsd_status),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sgxsd_status>())).code as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sgxsd_status),
            "::",
            stringify!(code)
        )
    );
}
impl Default for sgxsd_status {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type sgxsd_status_t = sgxsd_status;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sgxsd_enclave {
    pub id: sgx_enclave_id_t,
    pub __bindgen_anon_1: sgxsd_enclave__bindgen_ty_1,
    pub launch_token: sgx_launch_token_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sgxsd_enclave__bindgen_ty_1 {
    pub gid: sgx_epid_group_id_t,
    pub gid32: u32,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_sgxsd_enclave__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<sgxsd_enclave__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(sgxsd_enclave__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<sgxsd_enclave__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(sgxsd_enclave__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sgxsd_enclave__bindgen_ty_1>())).gid as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sgxsd_enclave__bindgen_ty_1),
            "::",
            stringify!(gid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sgxsd_enclave__bindgen_ty_1>())).gid32 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sgxsd_enclave__bindgen_ty_1),
            "::",
            stringify!(gid32)
        )
    );
}
impl Default for sgxsd_enclave__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_sgxsd_enclave() {
    assert_eq!(
        ::core::mem::size_of::<sgxsd_enclave>(),
        1040usize,
        concat!("Size of: ", stringify!(sgxsd_enclave))
    );
    assert_eq!(
        ::core::mem::align_of::<sgxsd_enclave>(),
        8usize,
        concat!("Alignment of ", stringify!(sgxsd_enclave))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sgxsd_enclave>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sgxsd_enclave),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sgxsd_enclave>())).launch_token as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sgxsd_enclave),
            "::",
            stringify!(launch_token)
        )
    );
}
impl Default for sgxsd_enclave {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type sgxsd_enclave_t = sgxsd_enclave;
pub type sgxsd_start_callback_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: sgxsd_enclave_t, arg2: *mut __va_list_tag) -> sgxsd_status_t,
>;
extern "C" {
    pub fn sgxsd_start(
        enclave_path: *const libc::c_char,
        debug: bool,
        p_node_init_args: *const sgxsd_node_init_args_t,
        p_callback: sgxsd_start_callback_t,
        ...
    ) -> sgxsd_status_t;
}
extern "C" {
    pub fn sgxsd_get_next_quote(
        enclave_id: sgx_enclave_id_t,
        spid: sgx_spid_t,
        p_sig_rl: *const u8,
        sig_rl_size: u32,
        p_quote: *mut sgx_quote_t,
        quote_size: u32,
    ) -> sgxsd_status_t;
}
pub const SGXSD_ERROR_PENDING_REQUEST_NOT_FOUND: sgxsd_status_code = 65537;
pub type sgxsd_status_code = u32;
pub use self::sgxsd_status_code as sgxsd_status_code_t;
pub type __m64 = [libc::c_longlong; 1usize];
pub type __v1di = [libc::c_longlong; 1usize];
pub type __v2si = [libc::c_int; 2usize];
pub type __v4hi = [libc::c_short; 4usize];
pub type __v8qi = [libc::c_char; 8usize];
pub type __v4si = [libc::c_int; 4usize];
pub type __v4sf = [f32; 4usize];
pub type __m128 = [f32; 4usize];
pub type __v4su = [libc::c_uint; 4usize];
extern "C" {
    pub fn _mm_sfence();
}
extern "C" {
    pub fn _mm_getcsr() -> libc::c_uint;
}
extern "C" {
    pub fn _mm_setcsr(__i: libc::c_uint);
}
pub type __m128d = [f64; 2usize];
pub type __m128i = [libc::c_longlong; 2usize];
pub type __v2df = [f64; 2usize];
pub type __v2di = [libc::c_longlong; 2usize];
pub type __v8hi = [libc::c_short; 8usize];
pub type __v16qi = [libc::c_char; 16usize];
pub type __v2du = [libc::c_ulonglong; 2usize];
pub type __v8hu = [libc::c_ushort; 8usize];
pub type __v16qu = [libc::c_uchar; 16usize];
pub type __v16qs = [libc::c_schar; 16usize];
extern "C" {
    pub fn _mm_clflush(__p: *const libc::c_void);
}
extern "C" {
    pub fn _mm_lfence();
}
extern "C" {
    pub fn _mm_mfence();
}
extern "C" {
    pub fn _mm_pause();
}
pub type __v4df = [f64; 4usize];
pub type __v8sf = [f32; 8usize];
pub type __v4di = [libc::c_longlong; 4usize];
pub type __v8si = [libc::c_int; 8usize];
pub type __v16hi = [libc::c_short; 16usize];
pub type __v32qi = [libc::c_char; 32usize];
pub type __v4du = [libc::c_ulonglong; 4usize];
pub type __v8su = [libc::c_uint; 8usize];
pub type __v16hu = [libc::c_ushort; 16usize];
pub type __v32qu = [libc::c_uchar; 32usize];
pub type __v32qs = [libc::c_schar; 32usize];
pub type __m256 = [f32; 8usize];
pub type __m256d = [f64; 4usize];
pub type __v64qi = [libc::c_char; 64usize];
pub type __v32hi = [libc::c_short; 32usize];
pub type __v8df = [f64; 8usize];
pub type __v16sf = [f32; 16usize];
pub type __v8di = [libc::c_longlong; 8usize];
pub type __v16si = [libc::c_int; 16usize];
pub type __v64qu = [libc::c_uchar; 64usize];
pub type __v32hu = [libc::c_ushort; 32usize];
pub type __v8du = [libc::c_ulonglong; 8usize];
pub type __v16su = [libc::c_uint; 16usize];
pub type __m512 = [f32; 16usize];
pub type __m512d = [f64; 8usize];
pub type __m512i = [libc::c_longlong; 8usize];
pub type __mmask8 = libc::c_uchar;
pub type __mmask16 = libc::c_ushort;
pub const _MM_CMPINT_EQ: _MM_CMPINT_ENUM = 0;
pub const _MM_CMPINT_LT: _MM_CMPINT_ENUM = 1;
pub const _MM_CMPINT_LE: _MM_CMPINT_ENUM = 2;
pub const _MM_CMPINT_UNUSED: _MM_CMPINT_ENUM = 3;
pub const _MM_CMPINT_NE: _MM_CMPINT_ENUM = 4;
pub const _MM_CMPINT_NLT: _MM_CMPINT_ENUM = 5;
pub const _MM_CMPINT_NLE: _MM_CMPINT_ENUM = 6;
pub type _MM_CMPINT_ENUM = u32;
pub const _MM_PERM_AAAA: _MM_PERM_ENUM = 0;
pub const _MM_PERM_AAAB: _MM_PERM_ENUM = 1;
pub const _MM_PERM_AAAC: _MM_PERM_ENUM = 2;
pub const _MM_PERM_AAAD: _MM_PERM_ENUM = 3;
pub const _MM_PERM_AABA: _MM_PERM_ENUM = 4;
pub const _MM_PERM_AABB: _MM_PERM_ENUM = 5;
pub const _MM_PERM_AABC: _MM_PERM_ENUM = 6;
pub const _MM_PERM_AABD: _MM_PERM_ENUM = 7;
pub const _MM_PERM_AACA: _MM_PERM_ENUM = 8;
pub const _MM_PERM_AACB: _MM_PERM_ENUM = 9;
pub const _MM_PERM_AACC: _MM_PERM_ENUM = 10;
pub const _MM_PERM_AACD: _MM_PERM_ENUM = 11;
pub const _MM_PERM_AADA: _MM_PERM_ENUM = 12;
pub const _MM_PERM_AADB: _MM_PERM_ENUM = 13;
pub const _MM_PERM_AADC: _MM_PERM_ENUM = 14;
pub const _MM_PERM_AADD: _MM_PERM_ENUM = 15;
pub const _MM_PERM_ABAA: _MM_PERM_ENUM = 16;
pub const _MM_PERM_ABAB: _MM_PERM_ENUM = 17;
pub const _MM_PERM_ABAC: _MM_PERM_ENUM = 18;
pub const _MM_PERM_ABAD: _MM_PERM_ENUM = 19;
pub const _MM_PERM_ABBA: _MM_PERM_ENUM = 20;
pub const _MM_PERM_ABBB: _MM_PERM_ENUM = 21;
pub const _MM_PERM_ABBC: _MM_PERM_ENUM = 22;
pub const _MM_PERM_ABBD: _MM_PERM_ENUM = 23;
pub const _MM_PERM_ABCA: _MM_PERM_ENUM = 24;
pub const _MM_PERM_ABCB: _MM_PERM_ENUM = 25;
pub const _MM_PERM_ABCC: _MM_PERM_ENUM = 26;
pub const _MM_PERM_ABCD: _MM_PERM_ENUM = 27;
pub const _MM_PERM_ABDA: _MM_PERM_ENUM = 28;
pub const _MM_PERM_ABDB: _MM_PERM_ENUM = 29;
pub const _MM_PERM_ABDC: _MM_PERM_ENUM = 30;
pub const _MM_PERM_ABDD: _MM_PERM_ENUM = 31;
pub const _MM_PERM_ACAA: _MM_PERM_ENUM = 32;
pub const _MM_PERM_ACAB: _MM_PERM_ENUM = 33;
pub const _MM_PERM_ACAC: _MM_PERM_ENUM = 34;
pub const _MM_PERM_ACAD: _MM_PERM_ENUM = 35;
pub const _MM_PERM_ACBA: _MM_PERM_ENUM = 36;
pub const _MM_PERM_ACBB: _MM_PERM_ENUM = 37;
pub const _MM_PERM_ACBC: _MM_PERM_ENUM = 38;
pub const _MM_PERM_ACBD: _MM_PERM_ENUM = 39;
pub const _MM_PERM_ACCA: _MM_PERM_ENUM = 40;
pub const _MM_PERM_ACCB: _MM_PERM_ENUM = 41;
pub const _MM_PERM_ACCC: _MM_PERM_ENUM = 42;
pub const _MM_PERM_ACCD: _MM_PERM_ENUM = 43;
pub const _MM_PERM_ACDA: _MM_PERM_ENUM = 44;
pub const _MM_PERM_ACDB: _MM_PERM_ENUM = 45;
pub const _MM_PERM_ACDC: _MM_PERM_ENUM = 46;
pub const _MM_PERM_ACDD: _MM_PERM_ENUM = 47;
pub const _MM_PERM_ADAA: _MM_PERM_ENUM = 48;
pub const _MM_PERM_ADAB: _MM_PERM_ENUM = 49;
pub const _MM_PERM_ADAC: _MM_PERM_ENUM = 50;
pub const _MM_PERM_ADAD: _MM_PERM_ENUM = 51;
pub const _MM_PERM_ADBA: _MM_PERM_ENUM = 52;
pub const _MM_PERM_ADBB: _MM_PERM_ENUM = 53;
pub const _MM_PERM_ADBC: _MM_PERM_ENUM = 54;
pub const _MM_PERM_ADBD: _MM_PERM_ENUM = 55;
pub const _MM_PERM_ADCA: _MM_PERM_ENUM = 56;
pub const _MM_PERM_ADCB: _MM_PERM_ENUM = 57;
pub const _MM_PERM_ADCC: _MM_PERM_ENUM = 58;
pub const _MM_PERM_ADCD: _MM_PERM_ENUM = 59;
pub const _MM_PERM_ADDA: _MM_PERM_ENUM = 60;
pub const _MM_PERM_ADDB: _MM_PERM_ENUM = 61;
pub const _MM_PERM_ADDC: _MM_PERM_ENUM = 62;
pub const _MM_PERM_ADDD: _MM_PERM_ENUM = 63;
pub const _MM_PERM_BAAA: _MM_PERM_ENUM = 64;
pub const _MM_PERM_BAAB: _MM_PERM_ENUM = 65;
pub const _MM_PERM_BAAC: _MM_PERM_ENUM = 66;
pub const _MM_PERM_BAAD: _MM_PERM_ENUM = 67;
pub const _MM_PERM_BABA: _MM_PERM_ENUM = 68;
pub const _MM_PERM_BABB: _MM_PERM_ENUM = 69;
pub const _MM_PERM_BABC: _MM_PERM_ENUM = 70;
pub const _MM_PERM_BABD: _MM_PERM_ENUM = 71;
pub const _MM_PERM_BACA: _MM_PERM_ENUM = 72;
pub const _MM_PERM_BACB: _MM_PERM_ENUM = 73;
pub const _MM_PERM_BACC: _MM_PERM_ENUM = 74;
pub const _MM_PERM_BACD: _MM_PERM_ENUM = 75;
pub const _MM_PERM_BADA: _MM_PERM_ENUM = 76;
pub const _MM_PERM_BADB: _MM_PERM_ENUM = 77;
pub const _MM_PERM_BADC: _MM_PERM_ENUM = 78;
pub const _MM_PERM_BADD: _MM_PERM_ENUM = 79;
pub const _MM_PERM_BBAA: _MM_PERM_ENUM = 80;
pub const _MM_PERM_BBAB: _MM_PERM_ENUM = 81;
pub const _MM_PERM_BBAC: _MM_PERM_ENUM = 82;
pub const _MM_PERM_BBAD: _MM_PERM_ENUM = 83;
pub const _MM_PERM_BBBA: _MM_PERM_ENUM = 84;
pub const _MM_PERM_BBBB: _MM_PERM_ENUM = 85;
pub const _MM_PERM_BBBC: _MM_PERM_ENUM = 86;
pub const _MM_PERM_BBBD: _MM_PERM_ENUM = 87;
pub const _MM_PERM_BBCA: _MM_PERM_ENUM = 88;
pub const _MM_PERM_BBCB: _MM_PERM_ENUM = 89;
pub const _MM_PERM_BBCC: _MM_PERM_ENUM = 90;
pub const _MM_PERM_BBCD: _MM_PERM_ENUM = 91;
pub const _MM_PERM_BBDA: _MM_PERM_ENUM = 92;
pub const _MM_PERM_BBDB: _MM_PERM_ENUM = 93;
pub const _MM_PERM_BBDC: _MM_PERM_ENUM = 94;
pub const _MM_PERM_BBDD: _MM_PERM_ENUM = 95;
pub const _MM_PERM_BCAA: _MM_PERM_ENUM = 96;
pub const _MM_PERM_BCAB: _MM_PERM_ENUM = 97;
pub const _MM_PERM_BCAC: _MM_PERM_ENUM = 98;
pub const _MM_PERM_BCAD: _MM_PERM_ENUM = 99;
pub const _MM_PERM_BCBA: _MM_PERM_ENUM = 100;
pub const _MM_PERM_BCBB: _MM_PERM_ENUM = 101;
pub const _MM_PERM_BCBC: _MM_PERM_ENUM = 102;
pub const _MM_PERM_BCBD: _MM_PERM_ENUM = 103;
pub const _MM_PERM_BCCA: _MM_PERM_ENUM = 104;
pub const _MM_PERM_BCCB: _MM_PERM_ENUM = 105;
pub const _MM_PERM_BCCC: _MM_PERM_ENUM = 106;
pub const _MM_PERM_BCCD: _MM_PERM_ENUM = 107;
pub const _MM_PERM_BCDA: _MM_PERM_ENUM = 108;
pub const _MM_PERM_BCDB: _MM_PERM_ENUM = 109;
pub const _MM_PERM_BCDC: _MM_PERM_ENUM = 110;
pub const _MM_PERM_BCDD: _MM_PERM_ENUM = 111;
pub const _MM_PERM_BDAA: _MM_PERM_ENUM = 112;
pub const _MM_PERM_BDAB: _MM_PERM_ENUM = 113;
pub const _MM_PERM_BDAC: _MM_PERM_ENUM = 114;
pub const _MM_PERM_BDAD: _MM_PERM_ENUM = 115;
pub const _MM_PERM_BDBA: _MM_PERM_ENUM = 116;
pub const _MM_PERM_BDBB: _MM_PERM_ENUM = 117;
pub const _MM_PERM_BDBC: _MM_PERM_ENUM = 118;
pub const _MM_PERM_BDBD: _MM_PERM_ENUM = 119;
pub const _MM_PERM_BDCA: _MM_PERM_ENUM = 120;
pub const _MM_PERM_BDCB: _MM_PERM_ENUM = 121;
pub const _MM_PERM_BDCC: _MM_PERM_ENUM = 122;
pub const _MM_PERM_BDCD: _MM_PERM_ENUM = 123;
pub const _MM_PERM_BDDA: _MM_PERM_ENUM = 124;
pub const _MM_PERM_BDDB: _MM_PERM_ENUM = 125;
pub const _MM_PERM_BDDC: _MM_PERM_ENUM = 126;
pub const _MM_PERM_BDDD: _MM_PERM_ENUM = 127;
pub const _MM_PERM_CAAA: _MM_PERM_ENUM = 128;
pub const _MM_PERM_CAAB: _MM_PERM_ENUM = 129;
pub const _MM_PERM_CAAC: _MM_PERM_ENUM = 130;
pub const _MM_PERM_CAAD: _MM_PERM_ENUM = 131;
pub const _MM_PERM_CABA: _MM_PERM_ENUM = 132;
pub const _MM_PERM_CABB: _MM_PERM_ENUM = 133;
pub const _MM_PERM_CABC: _MM_PERM_ENUM = 134;
pub const _MM_PERM_CABD: _MM_PERM_ENUM = 135;
pub const _MM_PERM_CACA: _MM_PERM_ENUM = 136;
pub const _MM_PERM_CACB: _MM_PERM_ENUM = 137;
pub const _MM_PERM_CACC: _MM_PERM_ENUM = 138;
pub const _MM_PERM_CACD: _MM_PERM_ENUM = 139;
pub const _MM_PERM_CADA: _MM_PERM_ENUM = 140;
pub const _MM_PERM_CADB: _MM_PERM_ENUM = 141;
pub const _MM_PERM_CADC: _MM_PERM_ENUM = 142;
pub const _MM_PERM_CADD: _MM_PERM_ENUM = 143;
pub const _MM_PERM_CBAA: _MM_PERM_ENUM = 144;
pub const _MM_PERM_CBAB: _MM_PERM_ENUM = 145;
pub const _MM_PERM_CBAC: _MM_PERM_ENUM = 146;
pub const _MM_PERM_CBAD: _MM_PERM_ENUM = 147;
pub const _MM_PERM_CBBA: _MM_PERM_ENUM = 148;
pub const _MM_PERM_CBBB: _MM_PERM_ENUM = 149;
pub const _MM_PERM_CBBC: _MM_PERM_ENUM = 150;
pub const _MM_PERM_CBBD: _MM_PERM_ENUM = 151;
pub const _MM_PERM_CBCA: _MM_PERM_ENUM = 152;
pub const _MM_PERM_CBCB: _MM_PERM_ENUM = 153;
pub const _MM_PERM_CBCC: _MM_PERM_ENUM = 154;
pub const _MM_PERM_CBCD: _MM_PERM_ENUM = 155;
pub const _MM_PERM_CBDA: _MM_PERM_ENUM = 156;
pub const _MM_PERM_CBDB: _MM_PERM_ENUM = 157;
pub const _MM_PERM_CBDC: _MM_PERM_ENUM = 158;
pub const _MM_PERM_CBDD: _MM_PERM_ENUM = 159;
pub const _MM_PERM_CCAA: _MM_PERM_ENUM = 160;
pub const _MM_PERM_CCAB: _MM_PERM_ENUM = 161;
pub const _MM_PERM_CCAC: _MM_PERM_ENUM = 162;
pub const _MM_PERM_CCAD: _MM_PERM_ENUM = 163;
pub const _MM_PERM_CCBA: _MM_PERM_ENUM = 164;
pub const _MM_PERM_CCBB: _MM_PERM_ENUM = 165;
pub const _MM_PERM_CCBC: _MM_PERM_ENUM = 166;
pub const _MM_PERM_CCBD: _MM_PERM_ENUM = 167;
pub const _MM_PERM_CCCA: _MM_PERM_ENUM = 168;
pub const _MM_PERM_CCCB: _MM_PERM_ENUM = 169;
pub const _MM_PERM_CCCC: _MM_PERM_ENUM = 170;
pub const _MM_PERM_CCCD: _MM_PERM_ENUM = 171;
pub const _MM_PERM_CCDA: _MM_PERM_ENUM = 172;
pub const _MM_PERM_CCDB: _MM_PERM_ENUM = 173;
pub const _MM_PERM_CCDC: _MM_PERM_ENUM = 174;
pub const _MM_PERM_CCDD: _MM_PERM_ENUM = 175;
pub const _MM_PERM_CDAA: _MM_PERM_ENUM = 176;
pub const _MM_PERM_CDAB: _MM_PERM_ENUM = 177;
pub const _MM_PERM_CDAC: _MM_PERM_ENUM = 178;
pub const _MM_PERM_CDAD: _MM_PERM_ENUM = 179;
pub const _MM_PERM_CDBA: _MM_PERM_ENUM = 180;
pub const _MM_PERM_CDBB: _MM_PERM_ENUM = 181;
pub const _MM_PERM_CDBC: _MM_PERM_ENUM = 182;
pub const _MM_PERM_CDBD: _MM_PERM_ENUM = 183;
pub const _MM_PERM_CDCA: _MM_PERM_ENUM = 184;
pub const _MM_PERM_CDCB: _MM_PERM_ENUM = 185;
pub const _MM_PERM_CDCC: _MM_PERM_ENUM = 186;
pub const _MM_PERM_CDCD: _MM_PERM_ENUM = 187;
pub const _MM_PERM_CDDA: _MM_PERM_ENUM = 188;
pub const _MM_PERM_CDDB: _MM_PERM_ENUM = 189;
pub const _MM_PERM_CDDC: _MM_PERM_ENUM = 190;
pub const _MM_PERM_CDDD: _MM_PERM_ENUM = 191;
pub const _MM_PERM_DAAA: _MM_PERM_ENUM = 192;
pub const _MM_PERM_DAAB: _MM_PERM_ENUM = 193;
pub const _MM_PERM_DAAC: _MM_PERM_ENUM = 194;
pub const _MM_PERM_DAAD: _MM_PERM_ENUM = 195;
pub const _MM_PERM_DABA: _MM_PERM_ENUM = 196;
pub const _MM_PERM_DABB: _MM_PERM_ENUM = 197;
pub const _MM_PERM_DABC: _MM_PERM_ENUM = 198;
pub const _MM_PERM_DABD: _MM_PERM_ENUM = 199;
pub const _MM_PERM_DACA: _MM_PERM_ENUM = 200;
pub const _MM_PERM_DACB: _MM_PERM_ENUM = 201;
pub const _MM_PERM_DACC: _MM_PERM_ENUM = 202;
pub const _MM_PERM_DACD: _MM_PERM_ENUM = 203;
pub const _MM_PERM_DADA: _MM_PERM_ENUM = 204;
pub const _MM_PERM_DADB: _MM_PERM_ENUM = 205;
pub const _MM_PERM_DADC: _MM_PERM_ENUM = 206;
pub const _MM_PERM_DADD: _MM_PERM_ENUM = 207;
pub const _MM_PERM_DBAA: _MM_PERM_ENUM = 208;
pub const _MM_PERM_DBAB: _MM_PERM_ENUM = 209;
pub const _MM_PERM_DBAC: _MM_PERM_ENUM = 210;
pub const _MM_PERM_DBAD: _MM_PERM_ENUM = 211;
pub const _MM_PERM_DBBA: _MM_PERM_ENUM = 212;
pub const _MM_PERM_DBBB: _MM_PERM_ENUM = 213;
pub const _MM_PERM_DBBC: _MM_PERM_ENUM = 214;
pub const _MM_PERM_DBBD: _MM_PERM_ENUM = 215;
pub const _MM_PERM_DBCA: _MM_PERM_ENUM = 216;
pub const _MM_PERM_DBCB: _MM_PERM_ENUM = 217;
pub const _MM_PERM_DBCC: _MM_PERM_ENUM = 218;
pub const _MM_PERM_DBCD: _MM_PERM_ENUM = 219;
pub const _MM_PERM_DBDA: _MM_PERM_ENUM = 220;
pub const _MM_PERM_DBDB: _MM_PERM_ENUM = 221;
pub const _MM_PERM_DBDC: _MM_PERM_ENUM = 222;
pub const _MM_PERM_DBDD: _MM_PERM_ENUM = 223;
pub const _MM_PERM_DCAA: _MM_PERM_ENUM = 224;
pub const _MM_PERM_DCAB: _MM_PERM_ENUM = 225;
pub const _MM_PERM_DCAC: _MM_PERM_ENUM = 226;
pub const _MM_PERM_DCAD: _MM_PERM_ENUM = 227;
pub const _MM_PERM_DCBA: _MM_PERM_ENUM = 228;
pub const _MM_PERM_DCBB: _MM_PERM_ENUM = 229;
pub const _MM_PERM_DCBC: _MM_PERM_ENUM = 230;
pub const _MM_PERM_DCBD: _MM_PERM_ENUM = 231;
pub const _MM_PERM_DCCA: _MM_PERM_ENUM = 232;
pub const _MM_PERM_DCCB: _MM_PERM_ENUM = 233;
pub const _MM_PERM_DCCC: _MM_PERM_ENUM = 234;
pub const _MM_PERM_DCCD: _MM_PERM_ENUM = 235;
pub const _MM_PERM_DCDA: _MM_PERM_ENUM = 236;
pub const _MM_PERM_DCDB: _MM_PERM_ENUM = 237;
pub const _MM_PERM_DCDC: _MM_PERM_ENUM = 238;
pub const _MM_PERM_DCDD: _MM_PERM_ENUM = 239;
pub const _MM_PERM_DDAA: _MM_PERM_ENUM = 240;
pub const _MM_PERM_DDAB: _MM_PERM_ENUM = 241;
pub const _MM_PERM_DDAC: _MM_PERM_ENUM = 242;
pub const _MM_PERM_DDAD: _MM_PERM_ENUM = 243;
pub const _MM_PERM_DDBA: _MM_PERM_ENUM = 244;
pub const _MM_PERM_DDBB: _MM_PERM_ENUM = 245;
pub const _MM_PERM_DDBC: _MM_PERM_ENUM = 246;
pub const _MM_PERM_DDBD: _MM_PERM_ENUM = 247;
pub const _MM_PERM_DDCA: _MM_PERM_ENUM = 248;
pub const _MM_PERM_DDCB: _MM_PERM_ENUM = 249;
pub const _MM_PERM_DDCC: _MM_PERM_ENUM = 250;
pub const _MM_PERM_DDCD: _MM_PERM_ENUM = 251;
pub const _MM_PERM_DDDA: _MM_PERM_ENUM = 252;
pub const _MM_PERM_DDDB: _MM_PERM_ENUM = 253;
pub const _MM_PERM_DDDC: _MM_PERM_ENUM = 254;
pub const _MM_PERM_DDDD: _MM_PERM_ENUM = 255;
pub type _MM_PERM_ENUM = u32;
pub const _MM_MANT_NORM_1_2: _MM_MANTISSA_NORM_ENUM = 0;
pub const _MM_MANT_NORM_p5_2: _MM_MANTISSA_NORM_ENUM = 1;
pub const _MM_MANT_NORM_p5_1: _MM_MANTISSA_NORM_ENUM = 2;
pub const _MM_MANT_NORM_p75_1p5: _MM_MANTISSA_NORM_ENUM = 3;
pub type _MM_MANTISSA_NORM_ENUM = u32;
pub const _MM_MANT_SIGN_src: _MM_MANTISSA_SIGN_ENUM = 0;
pub const _MM_MANT_SIGN_zero: _MM_MANTISSA_SIGN_ENUM = 1;
pub const _MM_MANT_SIGN_nan: _MM_MANTISSA_SIGN_ENUM = 2;
pub type _MM_MANTISSA_SIGN_ENUM = u32;
pub type __v2hi = [libc::c_short; 2usize];
pub type __v4qi = [libc::c_char; 4usize];
pub type __v2qi = [libc::c_char; 2usize];
pub type __mmask32 = libc::c_uint;
pub type __mmask64 = libc::c_ulonglong;
pub type __v2sf = [f32; 2usize];
pub type phone_t = u64;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct uuid {
    pub data64: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_uuid() {
    assert_eq!(
        ::core::mem::size_of::<uuid>(),
        16usize,
        concat!("Size of: ", stringify!(uuid))
    );
    assert_eq!(
        ::core::mem::align_of::<uuid>(),
        8usize,
        concat!("Alignment of ", stringify!(uuid))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<uuid>())).data64 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uuid),
            "::",
            stringify!(data64)
        )
    );
}
pub type uuid_t = uuid;
#[repr(C)]
#[repr(align(32))]
pub struct HashSlot {
    pub blocks: [__m256i; 4usize],
}
#[test]
fn bindgen_test_layout_HashSlot() {
    assert_eq!(
        ::core::mem::size_of::<HashSlot>(),
        128usize,
        concat!("Size of: ", stringify!(HashSlot))
    );
    assert_eq!(
        ::core::mem::align_of::<HashSlot>(),
        32usize,
        concat!("Alignment of ", stringify!(HashSlot))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HashSlot>())).blocks as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HashSlot),
            "::",
            stringify!(blocks)
        )
    );
}
impl Default for HashSlot {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(32))]
pub struct HashSlotResult {
    pub blocks: [[__m256i; 2usize]; 4usize],
}
#[test]
fn bindgen_test_layout_HashSlotResult() {
    assert_eq!(
        ::core::mem::size_of::<HashSlotResult>(),
        256usize,
        concat!("Size of: ", stringify!(HashSlotResult))
    );
    assert_eq!(
        ::core::mem::align_of::<HashSlotResult>(),
        32usize,
        concat!("Alignment of ", stringify!(HashSlotResult))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<HashSlotResult>())).blocks as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HashSlotResult),
            "::",
            stringify!(blocks)
        )
    );
}
impl Default for HashSlotResult {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn cds_hash_lookup(
        p_in_phones: *const phone_t,
        p_in_uuids: *const uuid_t,
        in_phone_count: usize,
        p_ab_phones: *const phone_t,
        p_ab_phone_results: *mut u8,
        ab_phone_count: usize,
        p_hash_slots: *mut HashSlot,
        p_hash_slot_results: *mut HashSlotResult,
        hash_slots_count: usize,
    ) -> u32;
}
#[repr(C)]
pub struct cds_encrypted_msg {
    pub iv: sgxsd_aes_gcm_iv_t,
    pub mac: sgxsd_aes_gcm_mac_t,
    pub size: u32,
    pub data: *mut u8,
}
#[test]
fn bindgen_test_layout_cds_encrypted_msg() {
    assert_eq!(
        ::core::mem::size_of::<cds_encrypted_msg>(),
        40usize,
        concat!("Size of: ", stringify!(cds_encrypted_msg))
    );
    assert_eq!(
        ::core::mem::align_of::<cds_encrypted_msg>(),
        8usize,
        concat!("Alignment of ", stringify!(cds_encrypted_msg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cds_encrypted_msg>())).iv as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cds_encrypted_msg),
            "::",
            stringify!(iv)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cds_encrypted_msg>())).mac as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cds_encrypted_msg),
            "::",
            stringify!(mac)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cds_encrypted_msg>())).size as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(cds_encrypted_msg),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cds_encrypted_msg>())).data as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cds_encrypted_msg),
            "::",
            stringify!(data)
        )
    );
}
impl Default for cds_encrypted_msg {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type cds_encrypted_msg_t = cds_encrypted_msg;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct sgxsd_server_init_args {
    pub max_query_phones: u32,
    pub max_ratelimit_states: u32,
}
#[test]
fn bindgen_test_layout_sgxsd_server_init_args() {
    assert_eq!(
        ::core::mem::size_of::<sgxsd_server_init_args>(),
        8usize,
        concat!("Size of: ", stringify!(sgxsd_server_init_args))
    );
    assert_eq!(
        ::core::mem::align_of::<sgxsd_server_init_args>(),
        4usize,
        concat!("Alignment of ", stringify!(sgxsd_server_init_args))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sgxsd_server_init_args>())).max_query_phones as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sgxsd_server_init_args),
            "::",
            stringify!(max_query_phones)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sgxsd_server_init_args>())).max_ratelimit_states as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sgxsd_server_init_args),
            "::",
            stringify!(max_ratelimit_states)
        )
    );
}
pub type sgxsd_server_init_args_t = sgxsd_server_init_args;
pub type cds_start_args_t = sgxsd_server_init_args;
#[repr(C)]
pub struct sgxsd_server_handle_call_args {
    pub query_phone_count: u32,
    pub ratelimit_state_size: u32,
    pub ratelimit_state_uuid: uuid_t,
    pub ratelimit_state_data: *mut u8,
    pub query: cds_encrypted_msg_t,
    pub query_commitment: [u8; 32usize],
}
#[test]
fn bindgen_test_layout_sgxsd_server_handle_call_args() {
    assert_eq!(
        ::core::mem::size_of::<sgxsd_server_handle_call_args>(),
        104usize,
        concat!("Size of: ", stringify!(sgxsd_server_handle_call_args))
    );
    assert_eq!(
        ::core::mem::align_of::<sgxsd_server_handle_call_args>(),
        8usize,
        concat!("Alignment of ", stringify!(sgxsd_server_handle_call_args))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sgxsd_server_handle_call_args>())).query_phone_count as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sgxsd_server_handle_call_args),
            "::",
            stringify!(query_phone_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sgxsd_server_handle_call_args>())).ratelimit_state_size
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sgxsd_server_handle_call_args),
            "::",
            stringify!(ratelimit_state_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sgxsd_server_handle_call_args>())).ratelimit_state_uuid
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sgxsd_server_handle_call_args),
            "::",
            stringify!(ratelimit_state_uuid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sgxsd_server_handle_call_args>())).ratelimit_state_data
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sgxsd_server_handle_call_args),
            "::",
            stringify!(ratelimit_state_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sgxsd_server_handle_call_args>())).query as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sgxsd_server_handle_call_args),
            "::",
            stringify!(query)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sgxsd_server_handle_call_args>())).query_commitment as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(sgxsd_server_handle_call_args),
            "::",
            stringify!(query_commitment)
        )
    );
}
impl Default for sgxsd_server_handle_call_args {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type sgxsd_server_handle_call_args_t = sgxsd_server_handle_call_args;
pub type cds_call_args_t = sgxsd_server_handle_call_args;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct sgxsd_server_terminate_args {
    pub in_phones: *mut phone_t,
    pub in_phone_count: usize,
    pub in_uuids: *mut uuid_t,
}
#[test]
fn bindgen_test_layout_sgxsd_server_terminate_args() {
    assert_eq!(
        ::core::mem::size_of::<sgxsd_server_terminate_args>(),
        24usize,
        concat!("Size of: ", stringify!(sgxsd_server_terminate_args))
    );
    assert_eq!(
        ::core::mem::align_of::<sgxsd_server_terminate_args>(),
        8usize,
        concat!("Alignment of ", stringify!(sgxsd_server_terminate_args))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sgxsd_server_terminate_args>())).in_phones as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sgxsd_server_terminate_args),
            "::",
            stringify!(in_phones)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sgxsd_server_terminate_args>())).in_phone_count as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sgxsd_server_terminate_args),
            "::",
            stringify!(in_phone_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sgxsd_server_terminate_args>())).in_uuids as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sgxsd_server_terminate_args),
            "::",
            stringify!(in_uuids)
        )
    );
}
impl Default for sgxsd_server_terminate_args {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type sgxsd_server_terminate_args_t = sgxsd_server_terminate_args;
pub type cds_stop_args_t = sgxsd_server_terminate_args;
pub const CDS_ERROR_INVALID_REQUEST_SIZE: cds_status_code = 131073;
pub const CDS_ERROR_QUERY_COMMITMENT_MISMATCH: cds_status_code = 131074;
pub type cds_status_code = u32;
pub use self::cds_status_code as cds_status_code_t;
extern "C" {
    pub fn sgxsd_enclave_node_init(p_args: *const sgxsd_node_init_args_t) -> sgx_status_t;
}
extern "C" {
    pub fn sgxsd_enclave_get_next_report(
        qe_target_info: sgx_target_info_t,
        p_report: *mut sgx_report_t,
    ) -> sgx_status_t;
}
extern "C" {
    pub fn sgxsd_enclave_set_current_quote() -> sgx_status_t;
}
extern "C" {
    pub fn sgxsd_enclave_negotiate_request(
        p_request: *const sgxsd_request_negotiation_request_t,
        p_response: *mut sgxsd_request_negotiation_response_t,
    ) -> sgx_status_t;
}
extern "C" {
    pub fn sgxsd_enclave_server_start(
        p_args: *const sgxsd_server_init_args_t,
        state_handle: sgxsd_server_state_handle_t,
    ) -> sgx_status_t;
}
extern "C" {
    pub fn sgxsd_enclave_server_call(
        p_args: *const sgxsd_server_handle_call_args_t,
        msg_header: *const sgxsd_msg_header_t,
        msg_data: *mut u8,
        msg_size: usize,
        msg_tag: sgxsd_msg_tag_t,
        state_handle: sgxsd_server_state_handle_t,
    ) -> sgx_status_t;
}
extern "C" {
    pub fn sgxsd_enclave_server_stop(
        p_args: *const sgxsd_server_terminate_args_t,
        state_handle: sgxsd_server_state_handle_t,
    ) -> sgx_status_t;
}
extern "C" {
    pub fn sgxsd_enclave_ratelimit_fingerprint(
        fingerprint_key: *mut u8,
        msg_header: *const sgxsd_msg_header_t,
        msg_data: *mut u8,
        msg_data_size: usize,
        msg_tag: sgxsd_msg_tag_t,
        fingerprint: *mut u8,
        fingerprint_size: usize,
    ) -> sgx_status_t;
}
extern "C" {
    pub fn sgxsd_ocall_reply(
        retval: *mut sgx_status_t,
        reply_header: *const sgxsd_msg_header_t,
        reply_data: *const u8,
        reply_data_size: usize,
        msg_tag: sgxsd_msg_tag_t,
    ) -> sgx_status_t;
}
pub type errno_t = libc::c_int;
extern "C" {
    pub fn memchr(arg1: *const libc::c_void, arg2: libc::c_int, arg3: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn memcmp(arg1: *const libc::c_void, arg2: *const libc::c_void, arg3: usize)
        -> libc::c_int;
}
extern "C" {
    pub fn memcpy(
        arg1: *mut libc::c_void,
        arg2: *const libc::c_void,
        arg3: usize,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn memmove(
        arg1: *mut libc::c_void,
        arg2: *const libc::c_void,
        arg3: usize,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn memset(arg1: *mut libc::c_void, arg2: libc::c_int, arg3: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn strchr(arg1: *const libc::c_char, arg2: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
    pub fn strcmp(arg1: *const libc::c_char, arg2: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn strcoll(arg1: *const libc::c_char, arg2: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn strcspn(arg1: *const libc::c_char, arg2: *const libc::c_char) -> usize;
}
extern "C" {
    pub fn strerror(arg1: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
    pub fn strlen(arg1: *const libc::c_char) -> usize;
}
extern "C" {
    pub fn strncat(
        arg1: *mut libc::c_char,
        arg2: *const libc::c_char,
        arg3: usize,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn strncmp(
        arg1: *const libc::c_char,
        arg2: *const libc::c_char,
        arg3: usize,
    ) -> libc::c_int;
}
extern "C" {
    pub fn strncpy(
        arg1: *mut libc::c_char,
        arg2: *const libc::c_char,
        arg3: usize,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn strpbrk(arg1: *const libc::c_char, arg2: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn strrchr(arg1: *const libc::c_char, arg2: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
    pub fn strspn(arg1: *const libc::c_char, arg2: *const libc::c_char) -> usize;
}
extern "C" {
    pub fn strstr(arg1: *const libc::c_char, arg2: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn strtok(arg1: *mut libc::c_char, arg2: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn strxfrm(arg1: *mut libc::c_char, arg2: *const libc::c_char, arg3: usize) -> usize;
}
extern "C" {
    pub fn strlcpy(arg1: *mut libc::c_char, arg2: *const libc::c_char, arg3: usize) -> usize;
}
extern "C" {
    pub fn memset_s(s: *mut libc::c_void, smax: usize, c: libc::c_int, n: usize) -> errno_t;
}
extern "C" {
    pub fn strndup(arg1: *const libc::c_char, arg2: usize) -> *mut libc::c_char;
}
extern "C" {
    pub fn strnlen(arg1: *const libc::c_char, arg2: usize) -> usize;
}
extern "C" {
    pub fn consttime_memequal(
        b1: *const libc::c_void,
        b2: *const libc::c_void,
        len: usize,
    ) -> libc::c_int;
}
extern "C" {
    pub fn bcmp(arg1: *const libc::c_void, arg2: *const libc::c_void, arg3: usize) -> libc::c_int;
}
extern "C" {
    pub fn bcopy(arg1: *const libc::c_void, arg2: *mut libc::c_void, arg3: usize);
}
extern "C" {
    pub fn bzero(arg1: *mut libc::c_void, arg2: usize);
}
extern "C" {
    pub fn index(arg1: *const libc::c_char, arg2: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
    pub fn mempcpy(
        arg1: *mut libc::c_void,
        arg2: *const libc::c_void,
        arg3: usize,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn rindex(arg1: *const libc::c_char, arg2: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
    pub fn stpncpy(
        dest: *mut libc::c_char,
        src: *const libc::c_char,
        n: usize,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn strcasecmp(arg1: *const libc::c_char, arg2: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn strncasecmp(
        arg1: *const libc::c_char,
        arg2: *const libc::c_char,
        arg3: usize,
    ) -> libc::c_int;
}
extern "C" {
    pub fn ffs(arg1: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn ffsl(arg1: libc::c_long) -> libc::c_int;
}
extern "C" {
    pub fn ffsll(arg1: libc::c_longlong) -> libc::c_int;
}
extern "C" {
    pub fn strtok_r(
        arg1: *mut libc::c_char,
        arg2: *const libc::c_char,
        arg3: *mut *mut libc::c_char,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn strerror_r(arg1: libc::c_int, arg2: *mut libc::c_char, arg3: usize) -> libc::c_int;
}
#[doc = " \\brief Type for a boolean."]
#[doc = ""]
#[doc = " This is conceptually a boolean; however, the C compiler sees it as"]
#[doc = " a type which may have many distinct values. It is meant to enable"]
#[doc = " or disable constant-time operations. This type is defined as a"]
#[doc = " `struct` so that it cannot be used directly to control a conditional"]
#[doc = " jump, since such an operation would contradict constant-time behaviour."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
pub struct cttk_bool {
    pub v: u32,
}
#[test]
fn bindgen_test_layout_cttk_bool() {
    assert_eq!(
        ::core::mem::size_of::<cttk_bool>(),
        4usize,
        concat!("Size of: ", stringify!(cttk_bool))
    );
    assert_eq!(
        ::core::mem::align_of::<cttk_bool>(),
        4usize,
        concat!("Alignment of ", stringify!(cttk_bool))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cttk_bool>())).v as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cttk_bool),
            "::",
            stringify!(v)
        )
    );
}
extern "C" {
    pub static cttk_true: cttk_bool;
}
extern "C" {
    pub static cttk_false: cttk_bool;
}
extern "C" {
    #[doc = " \\brief Conditionally copy data from `src` into `dst`."]
    #[doc = ""]
    #[doc = " If `ctl` is \"true\", then the `len` bytes starting at address `dst`"]
    #[doc = " are copied into `src`; otherwise, the contents of `dst` are unmodified."]
    #[doc = " `src` and `dst` may overlap partially or totally; in case of overlap,"]
    #[doc = " the new contents of the object pointed to by `dst` are set (if `ctl`"]
    #[doc = " is \"true\") to a copy of the contents of the source object before the"]
    #[doc = " operation. This matches the semantics of the standard function"]
    #[doc = " `memmove()`."]
    #[doc = ""]
    #[doc = " The object pointed to by `src` is unmodified, except in case of overlap"]
    #[doc = " with the destination object, as per the semantics explained above."]
    #[doc = ""]
    #[doc = " It is acceptable that `len` is zero, in which case nothing is copied."]
    #[doc = ""]
    #[doc = " \\param ctl   control value."]
    #[doc = " \\param dst   destination buffer."]
    #[doc = " \\param src   source buffer."]
    #[doc = " \\param len   number of bytes to conditionally copy."]
    pub fn cttk_cond_copy(
        ctl: cttk_bool,
        dst: *mut libc::c_void,
        src: *const libc::c_void,
        len: usize,
    );
}
extern "C" {
    #[doc = " \\brief Conditionally swap the contents of two memory areas."]
    #[doc = ""]
    #[doc = " If `ctl` is \"true\", then the `len` bytes located at the address `a`"]
    #[doc = " are copied into the `len` bytes located at the address `b`, and vice"]
    #[doc = " versa. If `ctl` is \"false\", then no value is modified. It is acceptable"]
    #[doc = " that `len` is zero, in which case no byte is modified."]
    #[doc = ""]
    #[doc = " The two areas MUST NOT overlap in any way."]
    #[doc = ""]
    #[doc = " \\param ctl   control value."]
    #[doc = " \\param a     first area."]
    #[doc = " \\param b     second area."]
    #[doc = " \\param len   number of bytes to conditionally swap."]
    pub fn cttk_cond_swap(ctl: cttk_bool, a: *mut libc::c_void, b: *mut libc::c_void, len: usize);
}
extern "C" {
    #[doc = " \\brief Constant-time array look-up (read)."]
    #[doc = ""]
    #[doc = " Given an array of `num_len` elements, of size `elt_len` bytes each,"]
    #[doc = " this function reads element `index` and writes it into the buffer `d`."]
    #[doc = " The value `a` points at the first array element, whose index is 0."]
    #[doc = " The array values _and_ the index are protected. The cost of this"]
    #[doc = " function is proportional to the total array size."]
    #[doc = ""]
    #[doc = " The caller is responsible for making sure that the requested index"]
    #[doc = " is within the proper array range."]
    #[doc = ""]
    #[doc = " \\param d         destination buffer (must have length at least `elt_len`)."]
    #[doc = " \\param a         pointer to first array element."]
    #[doc = " \\param elt_len   individual element length (in bytes)."]
    #[doc = " \\param num_len   number of elements in the array."]
    #[doc = " \\param index     index of the element to read."]
    pub fn cttk_array_read(
        d: *mut libc::c_void,
        a: *const libc::c_void,
        elt_len: usize,
        num_len: usize,
        index: usize,
    );
}
extern "C" {
    #[doc = " \\brief Constant-time array look-up (write)."]
    #[doc = ""]
    #[doc = " Given an array of `num_len` elements, of size `elt_len` bytes each,"]
    #[doc = " this function writes a given value into the array element at `index`."]
    #[doc = " The value `a` points at the first array element, whose index is 0."]
    #[doc = " The array values _and_ the index are protected. The cost of this"]
    #[doc = " function is proportional to the total array size."]
    #[doc = ""]
    #[doc = " The caller is responsible for making sure that the requested index"]
    #[doc = " is within the proper array range."]
    #[doc = ""]
    #[doc = " \\param a         pointer to first array element."]
    #[doc = " \\param elt_len   individual element length (in bytes)."]
    #[doc = " \\param num_len   number of elements in the array."]
    #[doc = " \\param index     index of the element to write."]
    #[doc = " \\param s         source value (`elt_len` bytes)."]
    pub fn cttk_array_write(
        a: *mut libc::c_void,
        elt_len: usize,
        num_len: usize,
        index: usize,
        s: *const libc::c_void,
    );
}
extern "C" {
    #[doc = " \\brief Constant-time comparison (equality)."]
    #[doc = ""]
    #[doc = " This function compares the two buffers at addresses `src1` and `src2`,"]
    #[doc = " both of length `len` bytes. Returned value is true if the buffers"]
    #[doc = " have equal contents, false otherwise."]
    #[doc = ""]
    #[doc = " All source bytes are touched; the comparison result, and the offset"]
    #[doc = " of the first differing byte, do not leak."]
    #[doc = ""]
    #[doc = " \\param src1   first buffer for comparison."]
    #[doc = " \\param src2   second buffer for comparison."]
    #[doc = " \\param len    buffer length (in bytes)."]
    #[doc = " \\return  true on equal contents."]
    pub fn cttk_array_eq(
        src1: *const libc::c_void,
        src2: *const libc::c_void,
        len: usize,
    ) -> cttk_bool;
}
extern "C" {
    #[doc = " \\brief Constant-time comparison (lexicographic order)."]
    #[doc = ""]
    #[doc = " This function compares the two buffers at addresses `src1` and `src2`,"]
    #[doc = " both of length `len` bytes. Returned value is -1, 0 or 1, depending"]
    #[doc = " on whether the first buffer is lower than, equal to, or greater than"]
    #[doc = " the second buffer. Lexicographic order is applied on the individual"]
    #[doc = " byte values, considered as unsigned integer in the 0 to 255 range."]
    #[doc = ""]
    #[doc = " All source bytes are touched; the comparison result, and the offset"]
    #[doc = " of the first differing byte, do not leak."]
    #[doc = ""]
    #[doc = " \\param src1   first buffer for comparison."]
    #[doc = " \\param src2   second buffer for comparison."]
    #[doc = " \\param len    buffer length (in bytes)."]
    #[doc = " \\return  -1, 0 or 1."]
    pub fn cttk_array_cmp(src1: *const libc::c_void, src2: *const libc::c_void, len: usize) -> i32;
}
extern "C" {
    #[doc = " \\brief Get the numerical value of an hexadecimal digit."]
    #[doc = ""]
    #[doc = " Hexadecimal digits are ASCII digits from `'0'` to `'9'`, and ASCII"]
    #[doc = " letters `'A'` to `'F'` (or `'a'` to `'f'`). This function returns"]
    #[doc = " the numerical value of the character, or -1 if the character is not"]
    #[doc = " an hexadecimal digit."]
    #[doc = ""]
    #[doc = " \\param c   hexadecimal digit."]
    #[doc = " \\return  the digit numerical value, or -1."]
    pub fn cttk_hexval(c: libc::c_char) -> libc::c_int;
}
extern "C" {
    #[doc = " \\brief Get the hexadecimal digit for a small value."]
    #[doc = ""]
    #[doc = " The source value `x` MUST be between 0 and 15, inclusive. Returned"]
    #[doc = " value is either an ASCII digit (`'0'` to `'9'`) or an ASCII"]
    #[doc = " letter (`'A'` to `'F'`, if `uppercase` is non-zero, or `'a'` to"]
    #[doc = " `'f'`, if `uppercase` is zero)."]
    #[doc = ""]
    #[doc = " \\param x           value to convert (0 to 15)."]
    #[doc = " \\param uppercase   non-zero to get an uppercase output."]
    #[doc = " \\return  the hexadecimal digit."]
    pub fn cttk_hexdigit(x: libc::c_int, uppercase: libc::c_int) -> libc::c_char;
}
extern "C" {
    #[doc = " \\brief Scan a source string for hexadecimal characters."]
    #[doc = ""]
    #[doc = " This function returns the offset of the first character in the"]
    #[doc = " provided string which is not \"acceptable\" by the hexadecimal parser."]
    #[doc = " Acceptable characters are ASCII digits, ASCII uppercase letters"]
    #[doc = " from `'A'` to `'F'`, and ASCII lowercase letters from `'a'` to `'f'`."]
    #[doc = " If `skipws` is non-zero, then whitespace is also considered acceptable"]
    #[doc = " (whitespace is ASCII space and ASCII all control characters, i.e."]
    #[doc = " codes from 0x00 to 0x20, inclusive)."]
    #[doc = ""]
    #[doc = " If all `src_len` characters are acceptable, then `src_len` is returned."]
    #[doc = ""]
    #[doc = " Constant-time: individual non-whitespace character values are protected."]
    #[doc = " Location of whitespace character, source length, and returned value,"]
    #[doc = " may leak."]
    #[doc = ""]
    #[doc = " \\param src       source string."]
    #[doc = " \\param src_len   source string length (in characters)."]
    #[doc = " \\param skipws    non-zero to accept whitespace as well."]
    #[doc = " \\return  the number of acceptable hex characters."]
    pub fn cttk_hexscan(src: *const libc::c_char, src_len: usize, skipws: libc::c_int) -> usize;
}
extern "C" {
    #[doc = " \\brief Convert an hexadecimal string into bytes."]
    #[doc = ""]
    #[doc = " The `src_len` characters, starting at address `src`, are parsed as"]
    #[doc = " hexadecimal digits; the resulting byte values are accumulated in"]
    #[doc = " `dst`. If `src_len` is 0, then it is acceptable that `src` is `NULL`."]
    #[doc = ""]
    #[doc = " If `dst` is `NULL`, then `dst_len` is ignored, and the returned value"]
    #[doc = " is the number of bytes that should have been produced. If `dst` is"]
    #[doc = " not `NULL`, then at most `dst_len` bytes are produced; if the source"]
    #[doc = " string contains more encoded bytes than can fit in `dst`, then an"]
    #[doc = " error is reported."]
    #[doc = ""]
    #[doc = " Upon any parsing error, decoding stops; the returned value is the"]
    #[doc = " number of bytes produced so far (or number of bytes that should have"]
    #[doc = " been produced, if `dst` is `NULL`). If `err` is not `NULL`, then"]
    #[doc = " `*err` is set to point at the first source character where the error"]
    #[doc = " was noticed. If the entire source string could be processed with no"]
    #[doc = " error, and `err` is not `NULL`, then `*err` is set to `NULL`."]
    #[doc = ""]
    #[doc = " When the error is an insufficient output buffer length, `*err` is"]
    #[doc = " set to point to the first hex digit that exceeds the capacity of the"]
    #[doc = " output buffer (regardless of whether that digit is alone or not). If"]
    #[doc = " `err` is `NULL`, then it is not possible to distinguish between a"]
    #[doc = " fully successful decoding, and an insufficient output buffer capacity."]
    #[doc = ""]
    #[doc = " The `flags` modify the decoding behaviour:"]
    #[doc = ""]
    #[doc = "   - If `CTTK_HEX_PAD_ODD` is set, then a final half-byte (the number of"]
    #[doc = "     hexadecimal digits was odd) is not considered an error, and an"]
    #[doc = "     implicit 0 is added. The padding is also applied if an invalid"]
    #[doc = "     character is encountered after an odd number of valid hex digits."]
    #[doc = "     If the number of hex digits is odd and that flag is _not_ set,"]
    #[doc = "     then the error will be reported as `*err` pointing to the character"]
    #[doc = "     immediately beyond the last one of the string."]
    #[doc = ""]
    #[doc = "   - If `CTTK_HEX_SKIP_WS` is set, then \"whitespace\" characters are"]
    #[doc = "     simply skipped and do not trigger an error. For the purposes of"]
    #[doc = "     this function, \"whitespace\" consists in bytes of value 32 or less"]
    #[doc = "     (i.e. ASCII space, and all ASCII control characters)."]
    #[doc = ""]
    #[doc = " Constant-time behaviour: the values of hex digits are protected, but"]
    #[doc = " not their number or location. Side channels may leak the total number"]
    #[doc = " of hex digits, and the position of whitespace characters (if skipped)."]
    #[doc = ""]
    #[doc = " \\param dst       destination buffer (or `NULL`)."]
    #[doc = " \\param dst_len   maximum size of the destination buffer (in bytes)."]
    #[doc = " \\param src       source string (can be `NULL` if `src_len` is zero)."]
    #[doc = " \\param src_len   source string length (in characters)."]
    #[doc = " \\param err       receiver for error character pointer, or `NULL`."]
    #[doc = " \\param flags     behavioural flags."]
    #[doc = " \\return  number of decoded bytes."]
    pub fn cttk_hextobin_gen(
        dst: *mut libc::c_void,
        dst_len: usize,
        src: *const libc::c_char,
        src_len: usize,
        err: *mut *const libc::c_char,
        flags: libc::c_uint,
    ) -> usize;
}
extern "C" {
    #[doc = " \\brief Encode bytes into hexadecimal."]
    #[doc = ""]
    #[doc = " The provided source bytes are encoded into hexadecimal. The destination"]
    #[doc = " buffer length (`dst_len`) must be large enough to accommodate the"]
    #[doc = " characters _and_ a terminating null byte."]
    #[doc = ""]
    #[doc = " If `dst` is `NULL`, then `dst_len` is ignored; the returned value will"]
    #[doc = " then be the number of digits that would be produced, i.e. exactly twice"]
    #[doc = " the value of `src_len`."]
    #[doc = ""]
    #[doc = " Returned value is the number of characters written, excluding the"]
    #[doc = " terminating null byte. The terminating null byte will still be written,"]
    #[doc = " except if `dst` is `NULL`, or `dst_len` is 0. If the output buffer is"]
    #[doc = " too small, then output is truncated, but still with a terminating 0."]
    #[doc = ""]
    #[doc = " The `flags` modify the behaviour:"]
    #[doc = ""]
    #[doc = "  - If `CTTK_HEX_UPPERCASE` is set, then produced hexadecimal digits"]
    #[doc = "    will use uppercase letters (`A` to `F`, for values 10 to 15)."]
    #[doc = "    Default behaviour is to use lowercase letters (`a` to `f`)."]
    #[doc = ""]
    #[doc = " Constant-time behaviour: the byte values are protected, but not the"]
    #[doc = " source or destination lengths."]
    #[doc = ""]
    #[doc = " \\param dst       destination buffer, or `NULL`."]
    #[doc = " \\param dst_len   destination buffer length (in characters)."]
    #[doc = " \\param src       source bytes (may be `NULL` if `src_len` is zero)."]
    #[doc = " \\param src_len   source length (in bytes)."]
    #[doc = " \\param flags     behavioural flags."]
    #[doc = " \\return  the number of hexadecimal digits produced."]
    pub fn cttk_bintohex_gen(
        dst: *mut libc::c_char,
        dst_len: usize,
        src: *const libc::c_void,
        src_len: usize,
        flags: libc::c_uint,
    ) -> usize;
}
extern "C" {
    #[doc = " \\brief Decode a Base64 string into bytes."]
    #[doc = ""]
    #[doc = " The `src_len` characters, starting at address `src`, are parsed as"]
    #[doc = " Base64 data; the resulting byte values are accumulated in"]
    #[doc = " `dst`. If `src_len` is 0, then it is acceptable that `src` is `NULL`."]
    #[doc = ""]
    #[doc = " If `dst` is `NULL`, then `dst_len` is ignored, and the returned value"]
    #[doc = " is the number of bytes that should have been produced. If `dst` is"]
    #[doc = " not `NULL`, then at most `dst_len` bytes are produced; if the source"]
    #[doc = " string contains more encoded bytes than can fit in `dst`, then an"]
    #[doc = " error is reported."]
    #[doc = ""]
    #[doc = " Upon any parsing error, decoding stops; the returned value is the"]
    #[doc = " number of bytes produced so far (or number of bytes that should have"]
    #[doc = " been produced, if `dst` is `NULL`). If `err` is not `NULL`, then"]
    #[doc = " `*err` is set to point at the first source character where the error"]
    #[doc = " was noticed. If the entire source string could be processed with no"]
    #[doc = " error, and `err` is not `NULL`, then `*err` is set to `NULL`."]
    #[doc = ""]
    #[doc = " When the error is an insufficient output buffer length, `*err` is set"]
    #[doc = " to point to the first character that makes the problem definite (in"]
    #[doc = " order to maintain strict constant-time processing, reporting of such"]
    #[doc = " a problem that could be detected only conditionally to the decoded"]
    #[doc = " bit values is delayed to the next character). If `err` is `NULL`,"]
    #[doc = " then it is not possible to distinguish between a fully successful"]
    #[doc = " decoding, and an insufficient output buffer capacity."]
    #[doc = ""]
    #[doc = " The `flags` modify the decoding behaviour:"]
    #[doc = ""]
    #[doc = "   - If `CTTK_B64DEC_NO_PAD` is set, then final padding characters"]
    #[doc = "     (`'='` signs) are not expected. If such a character is present,"]
    #[doc = "     then it will stop decoding at that point, and `*err` will be"]
    #[doc = "     set to point to that character."]
    #[doc = ""]
    #[doc = "   - If `CTTK_B64DEC_NO_WS` is set, then all source characters MUST"]
    #[doc = "     be Base64 characters; whitespace (including line breaks) will not"]
    #[doc = "     be tolerated, and be reported as an error if encountered. For the"]
    #[doc = "     purposes of this function, \"whitespace\" consists in bytes of"]
    #[doc = "     value 32 or less (i.e. ASCII space, and all ASCII control"]
    #[doc = "     characters)."]
    #[doc = ""]
    #[doc = " An error is reported, pointing at the first character past the source"]
    #[doc = " array, if the source buffer end is reached, or an `'='` padding sign"]
    #[doc = " is read, and there are non-zero buffered bits at that point."]
    #[doc = ""]
    #[doc = " Constant-time behaviour: the values of hex digits are protected, but"]
    #[doc = " not their number or location. Side channels may leak the total number"]
    #[doc = " of hex digits, and the position of whitespace characters (if skipped)."]
    #[doc = " If the source string is erroneous by having extra non-zero bits in the"]
    #[doc = " last chunk, then the value of these extra bits may leak as well (but"]
    #[doc = " not of the non-extra bits)."]
    #[doc = ""]
    #[doc = " \\param dst       destination buffer (or `NULL`)."]
    #[doc = " \\param dst_len   maximum size of the destination buffer (in bytes)."]
    #[doc = " \\param src       source string (can be `NULL` if `src_len` is zero)."]
    #[doc = " \\param src_len   source string length (in characters)."]
    #[doc = " \\param err       receiver for error character pointer, or `NULL`."]
    #[doc = " \\param flags     behavioural flags."]
    #[doc = " \\return  number of decoded bytes."]
    pub fn cttk_b64tobin_gen(
        dst: *mut libc::c_void,
        dst_len: usize,
        src: *const libc::c_char,
        src_len: usize,
        err: *mut *const libc::c_char,
        flags: libc::c_uint,
    ) -> usize;
}
extern "C" {
    #[doc = " \\brief Encode bytes into Base64."]
    #[doc = ""]
    #[doc = " The provided source bytes are encoded into Base64. The destination"]
    #[doc = " buffer length (`dst_len`) must be large enough to accommodate the"]
    #[doc = " characters _and_ a terminating null byte."]
    #[doc = ""]
    #[doc = " If `dst` is `NULL`, then `dst_len` is ignored; the returned value will"]
    #[doc = " then be the number of characters that would be produced (not counting"]
    #[doc = " the terminating null byte)."]
    #[doc = ""]
    #[doc = " Returned value is the number of characters written, excluding the"]
    #[doc = " terminating null byte. The terminating null byte will still be written,"]
    #[doc = " except if `dst` is `NULL`, or `dst_len` is 0."]
    #[doc = ""]
    #[doc = " The `flags` modify the behaviour:"]
    #[doc = ""]
    #[doc = "   - If `CTTK_B64ENC_NO_PAD` is set, then the final `'='` signs (for"]
    #[doc = "     padding the last character group, if needed) are not produced."]
    #[doc = ""]
    #[doc = "   - If `CTTK_B64ENC_NEWLINE` is set, then line breaks will be added"]
    #[doc = "     every 76 characters (by default). A line break will also be"]
    #[doc = "     produced at the end of the last line, unless the input is empty."]
    #[doc = ""]
    #[doc = "   - If `CTTK_B64ENC_CRLF` is set, then line breaks (if produced) will"]
    #[doc = "     use a CR+LF sequence (0x0D and 0x0A bytes, in that order). By"]
    #[doc = "     default, line breaks use a single LF (0x0A)."]
    #[doc = ""]
    #[doc = "   - If `CTTK_B64ENC_LINE64` is set, then line breaks (if produced)"]
    #[doc = "     will occur every 64 characters instead of the default of 76. Some"]
    #[doc = "     implementations of Base64 don't tolerate lines longer than 64"]
    #[doc = "     characters."]
    #[doc = ""]
    #[doc = " Constant-time behaviour: the source byte values are protected, but not"]
    #[doc = " the source or destination lengths."]
    #[doc = ""]
    #[doc = " \\param dst       destination buffer, or `NULL`."]
    #[doc = " \\param dst_len   destination buffer length (in characters)."]
    #[doc = " \\param src       source bytes (may be `NULL` if `src_len` is zero)."]
    #[doc = " \\param src_len   source length (in bytes)."]
    #[doc = " \\param flags     behavioural flags."]
    #[doc = " \\return  the number of characters produced."]
    pub fn cttk_bintob64_gen(
        dst: *mut libc::c_char,
        dst_len: usize,
        src: *const libc::c_void,
        src_len: usize,
        flags: libc::c_uint,
    ) -> usize;
}
extern "C" {
    #[doc = " \\brief Multiplication unsigned 32x32 -> 32."]
    #[doc = ""]
    #[doc = " Result is computed modulo 2^32 (no undefined behaviour on overflow)."]
    #[doc = ""]
    #[doc = " \\param x   first operand."]
    #[doc = " \\param y   second operand."]
    #[doc = " \\return  the result."]
    pub fn cttk_mulu32(x: u32, y: u32) -> u32;
}
extern "C" {
    #[doc = " \\brief Multiplication signed 32x32 -> 32."]
    #[doc = ""]
    #[doc = " This function guarantees two's complement behaviour with truncation"]
    #[doc = " to the low 32 bits (no undefined behaviour on overflow/underflow)."]
    #[doc = ""]
    #[doc = " \\param x   first operand."]
    #[doc = " \\param y   second operand."]
    #[doc = " \\return  the result."]
    pub fn cttk_muls32(x: i32, y: i32) -> i32;
}
extern "C" {
    #[doc = " \\brief Multiplication unsigned 32x32 -> 64."]
    #[doc = ""]
    #[doc = " \\param x   first operand."]
    #[doc = " \\param y   second operand."]
    #[doc = " \\return  the result."]
    pub fn cttk_mulu32w(x: u32, y: u32) -> u64;
}
extern "C" {
    #[doc = " \\brief Multiplication signed 32x32 -> 64."]
    #[doc = ""]
    #[doc = " \\param x   first operand."]
    #[doc = " \\param y   second operand."]
    #[doc = " \\return  the result."]
    pub fn cttk_muls32w(x: i32, y: i32) -> i64;
}
extern "C" {
    #[doc = " \\brief Multiplication unsigned 64x64 -> 64."]
    #[doc = ""]
    #[doc = " Result is computed modulo 2^64 (no undefined behaviour on overflow)."]
    #[doc = ""]
    #[doc = " \\param x   first operand."]
    #[doc = " \\param y   second operand."]
    #[doc = " \\return  the result."]
    pub fn cttk_mulu64(x: u64, y: u64) -> u64;
}
extern "C" {
    #[doc = " \\brief Multiplication signed 64x64 -> 64."]
    #[doc = ""]
    #[doc = " This function guarantees two's complement behaviour with truncation"]
    #[doc = " to the low 64 bits (no undefined behaviour on overflow/underflow)."]
    #[doc = ""]
    #[doc = " \\param x   first operand."]
    #[doc = " \\param y   second operand."]
    #[doc = " \\return  the result."]
    pub fn cttk_muls64(x: i64, y: i64) -> i64;
}
extern "C" {
    pub fn cttk_i31_init(x: *mut u32, size: libc::c_uint);
}
extern "C" {
    pub fn cttk_i31_set_u32(x: *mut u32, v: u32);
}
extern "C" {
    pub fn cttk_i31_set_u32_trunc(x: *mut u32, v: u32);
}
extern "C" {
    pub fn cttk_i31_set_u64(x: *mut u32, v: u64);
}
extern "C" {
    pub fn cttk_i31_set_u64_trunc(x: *mut u32, v: u64);
}
extern "C" {
    pub fn cttk_i31_set_s32(x: *mut u32, v: i32);
}
extern "C" {
    pub fn cttk_i31_set_s64(x: *mut u32, v: i64);
}
extern "C" {
    pub fn cttk_i31_set(d: *mut u32, a: *const u32);
}
extern "C" {
    pub fn cttk_i31_set_trunc(d: *mut u32, a: *const u32);
}
extern "C" {
    pub fn cttk_i31_to_u32_trunc(x: *const u32) -> u32;
}
extern "C" {
    pub fn cttk_i31_to_s32_trunc(x: *const u32) -> i32;
}
extern "C" {
    pub fn cttk_i31_to_u64_trunc(x: *const u32) -> u64;
}
extern "C" {
    pub fn cttk_i31_to_s64_trunc(x: *const u32) -> i64;
}
extern "C" {
    pub fn cttk_i31_to_u32(x: *const u32) -> u32;
}
extern "C" {
    pub fn cttk_i31_to_s32(x: *const u32) -> i32;
}
extern "C" {
    pub fn cttk_i31_to_u64(x: *const u32) -> u64;
}
extern "C" {
    pub fn cttk_i31_to_s64(x: *const u32) -> i64;
}
extern "C" {
    pub fn cttk_i31_decbe_signed(x: *mut u32, src: *const libc::c_void, len: usize);
}
extern "C" {
    pub fn cttk_i31_decbe_unsigned(x: *mut u32, src: *const libc::c_void, len: usize);
}
extern "C" {
    pub fn cttk_i31_decbe_signed_trunc(x: *mut u32, src: *const libc::c_void, len: usize);
}
extern "C" {
    pub fn cttk_i31_decbe_unsigned_trunc(x: *mut u32, src: *const libc::c_void, len: usize);
}
extern "C" {
    pub fn cttk_i31_decle_signed(x: *mut u32, src: *const libc::c_void, len: usize);
}
extern "C" {
    pub fn cttk_i31_decle_unsigned(x: *mut u32, src: *const libc::c_void, len: usize);
}
extern "C" {
    pub fn cttk_i31_decle_signed_trunc(x: *mut u32, src: *const libc::c_void, len: usize);
}
extern "C" {
    pub fn cttk_i31_decle_unsigned_trunc(x: *mut u32, src: *const libc::c_void, len: usize);
}
extern "C" {
    pub fn cttk_i31_encbe(dst: *mut libc::c_void, len: usize, x: *const u32);
}
extern "C" {
    pub fn cttk_i31_encle(dst: *mut libc::c_void, len: usize, x: *const u32);
}
extern "C" {
    pub fn cttk_i31_eq0(x: *const u32) -> cttk_bool;
}
extern "C" {
    pub fn cttk_i31_neq0(x: *const u32) -> cttk_bool;
}
extern "C" {
    pub fn cttk_i31_gt0(x: *const u32) -> cttk_bool;
}
extern "C" {
    pub fn cttk_i31_lt0(x: *const u32) -> cttk_bool;
}
extern "C" {
    pub fn cttk_i31_geq0(x: *const u32) -> cttk_bool;
}
extern "C" {
    pub fn cttk_i31_leq0(x: *const u32) -> cttk_bool;
}
extern "C" {
    pub fn cttk_i31_eq(x: *const u32, y: *const u32) -> cttk_bool;
}
extern "C" {
    pub fn cttk_i31_neq(x: *const u32, y: *const u32) -> cttk_bool;
}
extern "C" {
    pub fn cttk_i31_lt(x: *const u32, y: *const u32) -> cttk_bool;
}
extern "C" {
    pub fn cttk_i31_leq(x: *const u32, y: *const u32) -> cttk_bool;
}
extern "C" {
    pub fn cttk_i31_gt(x: *const u32, y: *const u32) -> cttk_bool;
}
extern "C" {
    pub fn cttk_i31_geq(x: *const u32, y: *const u32) -> cttk_bool;
}
extern "C" {
    pub fn cttk_i31_sign(x: *const u32) -> libc::c_int;
}
extern "C" {
    pub fn cttk_i31_cmp(x: *const u32, y: *const u32) -> i32;
}
extern "C" {
    pub fn cttk_i31_copy(d: *mut u32, s: *const u32);
}
extern "C" {
    pub fn cttk_i31_cond_copy(ctl: cttk_bool, d: *mut u32, s: *const u32);
}
extern "C" {
    pub fn cttk_i31_swap(a: *mut u32, b: *mut u32);
}
extern "C" {
    pub fn cttk_i31_cond_swap(ctl: cttk_bool, a: *mut u32, b: *mut u32);
}
extern "C" {
    pub fn cttk_i31_mux(ctl: cttk_bool, d: *mut u32, a: *const u32, b: *const u32);
}
extern "C" {
    pub fn cttk_i31_add(d: *mut u32, a: *const u32, b: *const u32);
}
extern "C" {
    pub fn cttk_i31_add_trunc(d: *mut u32, a: *const u32, b: *const u32);
}
extern "C" {
    pub fn cttk_i31_sub(d: *mut u32, a: *const u32, b: *const u32);
}
extern "C" {
    pub fn cttk_i31_sub_trunc(d: *mut u32, a: *const u32, b: *const u32);
}
extern "C" {
    pub fn cttk_i31_neg(d: *mut u32, x: *const u32);
}
extern "C" {
    pub fn cttk_i31_neg_trunc(d: *mut u32, x: *const u32);
}
extern "C" {
    pub fn cttk_i31_mul(d: *mut u32, a: *const u32, b: *const u32);
}
extern "C" {
    pub fn cttk_i31_mul_trunc(d: *mut u32, a: *const u32, b: *const u32);
}
extern "C" {
    pub fn cttk_i31_lsh(d: *mut u32, a: *const u32, n: u32);
}
extern "C" {
    pub fn cttk_i31_lsh_prot(d: *mut u32, a: *const u32, n: u32);
}
extern "C" {
    pub fn cttk_i31_lsh_trunc(d: *mut u32, a: *const u32, n: u32);
}
extern "C" {
    pub fn cttk_i31_lsh_trunc_prot(d: *mut u32, a: *const u32, n: u32);
}
extern "C" {
    pub fn cttk_i31_rsh(d: *mut u32, a: *const u32, n: u32);
}
extern "C" {
    pub fn cttk_i31_rsh_prot(d: *mut u32, a: *const u32, n: u32);
}
extern "C" {
    pub fn cttk_i31_divrem(q: *mut u32, r: *mut u32, a: *const u32, b: *const u32);
}
extern "C" {
    pub fn cttk_i31_mod(d: *mut u32, a: *const u32, b: *const u32);
}
extern "C" {
    pub fn cttk_i31_and(d: *mut u32, a: *const u32, b: *const u32);
}
extern "C" {
    pub fn cttk_i31_or(d: *mut u32, a: *const u32, b: *const u32);
}
extern "C" {
    pub fn cttk_i31_xor(d: *mut u32, a: *const u32, b: *const u32);
}
extern "C" {
    pub fn cttk_i31_eqv(d: *mut u32, a: *const u32, b: *const u32);
}
extern "C" {
    pub fn cttk_i31_not(d: *mut u32, a: *const u32);
}
pub type cti65_t = [u32; 4usize];
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __va_list_tag {
    pub gp_offset: libc::c_uint,
    pub fp_offset: libc::c_uint,
    pub overflow_arg_area: *mut libc::c_void,
    pub reg_save_area: *mut libc::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::core::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::core::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
impl Default for __va_list_tag {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
